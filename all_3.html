<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Hack Notes
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="Hack Notes" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:forrestchang.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        <li id=""><a target="_blank" href="portfolio.html">Portfolio</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Hack Notes</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="life.html">Life</a></li>
        
            <li><a href="machine-learning.html">ML</a></li>
        
            <li><a href="python.html">Python</a></li>
        
            <li><a href="productivity.html">Productivity</a></li>
        
            <li><a href="technology.html">Tech</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14636395892916.html">
                
                  <h1>2016 Week 21 阅读笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0"><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎样花两年时间去面试一个人</a></h2>

<blockquote>
<p>The great software developers, indeed, the best people in every field, are quite simply never on the market.j</p>

<p>The average great software developer will apply for, total,maybe, four jobs in their entire career.</p>

<p>—— <a href="http://www.joelonsoftware.com/articles/FindingGreatDevelopers.html">Joel Spolsky</a></p>

<ol>
<li>最好的人也许不投简历，就决定去哪里了。所以要在他们做决定之前找到他们。</li>
<li>比较差的会投很多次简历，找不到工作的时间约多，投的简历越多，给整个 pool 带来很多噪音，top 10% 的简历也许根本不算全部人的 top 10%。</li>
</ol>

<p>—— 邹欣</p>
</blockquote>

<p>Joel Spolsky 写了一本书，专门讲了公司招聘的心得和体会，<a href="http://www.amazon.com/Smart-Gets-Things-Done-Technical/dp/1590598385/">《Smart and Gets Things Done》</a>。</p>

<p>现在绝大多数应届生简历而言，也许最具信息量的部分不是「精通 xxx，熟悉 yyy，掌握 zzz」，不是「在 uuu 实习过」，也不是这个项目那个作业，反倒是越来越被认为不重要的一项：毕业学校。原因是简历上的其他条目的信息量太小了。</p>

<p>很多时候，是否好好看完一本好书，对一个人的提升往往能达到质的区别。就算不好好看完一本书，马马虎虎看完，只要书是真的函数，也肯定会有很大提高。</p>

<p>好书和坏书的差别，从本质上，就是学习效率和大方向的差别。读烂书浪费时间，但读好书却节省时间。</p>

<p>「书单计划」的优点：</p>

<ol>
<li>清晰、明确。完全可度量。</li>
<li>防伪：读没读过，随便一问便知。而正因为应聘者也知道这事不像实习经验可以忽悠，所以也不敢乱往简历上捅词。</li>
<li>不在乎是否「泄题」：书单是完全公开的，无所谓，本来就是要你去读的。</li>
<li>管你用心不用心读，只要读了，读完了，就有区别。（笔者注：根据经验，没有用心读完可能真的没有什么卵用）</li>
<li>不存在「怎么做」的障碍：所有人都知道怎么读书——一页一页读。</li>
<li>不需要招聘者投入精力：书单在此，就这么简单。</li>
<li>评估的负担很大程度上转移到了应聘者身上：是不是认真看完了，有没有心得体会。</li>
</ol>

<p>「书单计划」的背后是另一个悲剧的现实，如果不是因为这个现实，这个计划也完全没有必要，那就是，中国 IT 大学教育当中要求学的书，和企业真正需要你读的书相比，不是完全不够用，就是写得不够好，或者更悲剧的就是根本用不上，所以在这个大背景下出来的牛人都是自己淘书自己学的。</p>

<blockquote>
<p>第一份工作的月薪 = 大学四年买过的技术书籍价格的总和</p>

<p>—— 熊力</p>
</blockquote>

<p><strong>GitHub</strong></p>

<p>有经验的面试者只要稍稍扫两眼一个人的 GitHub 历史，跳出几个 check-in 历史看一看，便完全能够迅速判断这个人是否满足他的要求。不再需要费劲心机地去想题目，去观察，去揣测，去花费大量的时间的同时还只能采样到几个极为有限的点。</p>

<p>书单 + GitHub，就相当于一个两年左右的面试。</p>

<p>没有哪个行业像 IT 行业这样特殊：没有什么东西不能够（应该）在互联网上学到的。</p>

<hr/>

<p>一些书单</p>

<ol>
<li>《编码的奥秘》</li>
<li>《深入理解计算机系统》</li>
<li>《Windows 核心编程》</li>
<li>《程序员的自我修养》</li>
<li>《代码大全》</li>
<li>《程序员修炼之道》</li>
<li>《编程珠玑》</li>
<li>《编程之美》</li>
<li>《The C Programming Language》</li>
<li>《The C++ Programming Language》</li>
<li>《Programming: Principles and Practice Using C++》</li>
<li>《Accelerated C++》</li>
<li>《计算机程序的构造和解释》</li>
<li>《Clean Code》</li>
<li>《Implementation Patterns》</li>
<li>《Design Patterns》</li>
<li>《Agile Software Development, Principles, Patterns, and Practices》</li>
<li>《Refactoring》</li>
<li>《C++ 编程思想》</li>
<li>《Effective C++》</li>
<li>《深度探索 C++ 对象模型》</li>
<li>《C++ 语言的设计和演化》</li>
<li>《C 专家编程》</li>
<li>《C 陷阱与缺陷》</li>
<li>《C 语言接口与实现》</li>
<li>《Lua 程序设计》</li>
<li>《Linkers and Loaders》</li>
<li>《COM 本质论》</li>
<li>《深入理解 Windows 操作系统》</li>
<li>《Unix 编程艺术》</li>
<li>《代码优化：有效使用内存》</li>
<li>《深入理解 Linux 内核》</li>
<li>《TCP/IP 详解》</li>
<li>《软件随想录》</li>
<li>《黑客与画家》</li>
<li>《编程人生》</li>
<li>《人月神话》</li>
<li>《算法导论》</li>
<li>《快速软件开发——有效控制与完成进度计划》</li>
<li>《IT 项目管理那些事》</li>
<li>《最后期限》</li>
<li>《走出软件作坊》</li>
<li>《你的灯亮着吗》</li>
<li>《Algorithms》(by Sanjoy Dasgupta, Christos Papadimitriou and Umesh Vazirani)</li>
<li>《Data Structures and Algorithms》</li>
<li>《The Design of the UNIX Operating System》</li>
<li>《Compilers》(龙书)</li>
<li>《Computer Architecture: A Quantitative Approach》</li>
<li>《Flow》</li>
<li>《Outliers》（Why hard work and luck are both important）</li>
</ol>

<h2 id="toc_1"><a href="http://mindhacks.cn/2008/09/17/learning-habits-part3/">一直以来伴随我的一些学习习惯（三）：阅读方法</a></h2>

<ol>
<li>乘着对一件事有热情的时候，一股脑把万事那个最难的阶段熬过去。</li>
<li>根据主题来查阅资料，而不是根据资料来查阅主题。按照主题来阅读，你会发现读的时候不再是老老实实地一本书看完再看另一本，而是非常频繁地从一本书跳到另一本书，从一处资料跳到另一处资料，从而来获得多个不同的人对同一个主题是如何讲解的。因为即便是经典的书，你也不能指望它对其中每一个主题的介绍都是尽善尽美的，有些书对某个主题（知识点）的介绍比较到位，有些书则对另一些知识点介绍得比较到位。而有时候一篇紧凑的 paper 比一本书上讲得还要好。我硬盘里面的书按照主题分类，每个主题下面都有一堆书，当我需要学习某个主题的知识时，我会把里面涉及这个主题的书都翻开来，索引到相关章节，然后挑讲得好的看。</li>
<li>好资料，坏资料。好资料的特点：从问题出发；重点介绍方法背后的理念，注重直观解释，而不是方法的技术细节；按照方法被发明的时间流程来介绍（先是遇到什么问题，然后怎样分析，推理，最后发现目前所使用的方法）。坏资料的特点是好资料的反面：上来就讲方法细节，仿佛某方法是从天上掉下来的。根本不讲为什么要用这个方法，人们最初是因为面对什么问题才想到这个方法的，其间又是怎样才想出这个方法的，方法背后的直观思想又是什么。</li>
<li>学习一个东西之前，首先在大脑中积累充分的「疑惑感」。即弄清面临的问题到底是什么，在浏览方法本身之前，最好先使劲问问自己能想到什么方法。一个公认的事实是，你对问题的疑惑越大，在之前做的自己的思考越多，当看到借到之后的印象就越深刻。</li>
<li>有选择地阅读。这里的选择体现在两个地方，一是选择一本书中感兴趣的章节优先阅读，二是对一本书中技术性较弱或信息密度较低的部分快速地略读。一般来说，除了技术性非常强的书之外，大多数书的信息密度很低，有很多废话。一般来说在阅读的时候应该这样来切分内容：1. 问题是什么？2. 方案是什么？3. 例子是什么？如果是需要解释一个现象的，那么1. 现象是什么？2. 解释是什么？3. 之城这个解释的理由是什么？ 4. 例子是什么。</li>
<li>为什么看不懂？1. 你看得不够使劲。对于这类情况，仔仔细细地再多读两遍，多试着去理解两遍，往往会恍然大悟。2. 其中涉及到了你不懂得概念，这是技术性的不理解，这种情况就需要 Cross Reference。如果一句话中用到了你不懂得概念，那就去查。奇怪的是很多人看不懂也不分析一下为什么不懂，就直接放弃了。正如解决问题一样，问题卡住解决不了了，第一时间要做的就是分析为什么解决不了，而不是直接求救。3. 作者讲述的顺序不对，你接着往下看，也许看到后面就明白前面的了。</li>
<li>如何搜寻到好书。1. 同作者的著作。2. Amazon 相关推荐和主题相关的书列。3. 一本好的著作（或一份好的资料——不管是书还是网页）在参考资料里面重点提到的其他著作。4. 有时对于一个主题，可以搜索到好心人总结的参考资源导引，那是最好不过的。</li>
</ol>

<h2 id="toc_2"><a href="http://matt.might.net/articles/what-cs-majors-should-know/">What every computer science major should know</a></h2>

<ul>
<li>What should every student know to get a good job?</li>
<li>Waht should every student know to maintain lifelong employment?</li>
<li>What should every student know to enter graduate school?</li>
<li>What should every student know to benefit society?</li>
</ul>

<p><strong>Portfolio versus resume</strong></p>

<p>Every computer science major should build a portfolio.</p>

<p>A portfolio could be as simple as a personal blog, with a post for each project or accomplishment. A better portfolio would include per-project pages, and publicly browsable code (hosted perhaps on github or Google code).</p>

<p>Contributions to open source shold be linked and documented.</p>

<p>A code portflolio allows employers to direcctly judge ablility. GPAs and resumes do not.</p>

<p><strong>Technical communication</strong></p>

<p>I would recommend that students master a presentation tool like PowerPoint or (my favorite) Keynote.</p>

<p>For producing beautiful mathematival documentation, \(LaTex\) has not equal. All written assignments in techical courses should be submitted in LaTex.</p>

<p><strong>An engineering core</strong></p>

<p><strong>The Unix philosophy</strong></p>

<p>The Unix philosophy is one that emphassizes linguistic abstraction and composition in order to effect computation.</p>

<p><strong>Systems administration</strong></p>

<p><strong>Programming Language</strong></p>

<p><strong>Discrete mathematics</strong></p>

<p><strong>Data structures and algorithms</strong></p>

<p><strong>Theory</strong></p>

<p><strong>Architecture</strong></p>

<p><strong>Operating System</strong></p>

<p><strong>Networking</strong></p>

<p><strong>Security</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/5/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='technology.html'>Tech</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="http://forrestchang.github.io/14636395892916.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14635617646524.html">
                
                  <h1>Swift学习笔记：控制流</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Repeat-While</h2>

<p><code>repeat-while</code> 在 <code>while</code> 判断循环条件之前，先执行一次循环的代码块，和其他语言中的 <code>do-while</code> 是类似的。</p>

<pre><code class="language-swift">repeat {
    statements
} while condition
</code></pre>

<h2 id="toc_1">Switch</h2>

<p><code>switch</code> 语句会尝试把某个值与若干个模式（pattern）进行匹配。根据第一个匹配成功的模式，<code>switch</code>语句会执行对应的代码。当有可能的情况较多时，通常用 <code>switch</code> 语句替换 <code>if</code> 语句。</p>

<p><code>switch</code> 语句必须是完备的，每一个可能的值都必须至少有一个 case 分支与之对应。在某些不可能涵盖所有值得情况下，你可以使用默认（<code>default</code>）分支满足该要求，这个默认分支必须在 <code>switch</code> 语句的最后面。</p>

<h3 id="toc_2">不存在隐式的贯穿（No Implicit Fallthrouth）</h3>

<p>和其他语言的 Switch 不同，在 Swift 中，当匹配的 case 分支中的代码执行完毕后，程序会终止 <code>switch</code> 语句，而不会继续执行下一个 case 分支。所以，不需要再 case 分支中显式地使用 <code>break</code> 语句。</p>

<p>如果想要贯穿到特定的 case 分支中，请使用 <code>fallthrough</code> 语句。</p>

<h3 id="toc_3">区间匹配</h3>

<p>case 分支的模式也可以是一个值得区间。</p>

<h3 id="toc_4">元组</h3>

<p>可以只用元组在同一个 <code>switch</code> 语句中测试多个值，元组中的元素可以是值，也可以是区间，使用下划线 <code>_</code> 来匹配所有可能的值。</p>

<h3 id="toc_5">值绑定</h3>

<p>case 分支的模式允许将匹配的值绑定到一个临时的常量或变量，这些常量或变量在该 case 分支里就可以被引用了。</p>

<p>case 分支的模式可以使用 <code>where</code> 语句来判断额外的条件。</p>

<h2 id="toc_6">控制转移语句</h2>

<h3 id="toc_7">continue</h3>

<p><code>continue</code> 语句告诉一个循环体立刻停止本次循环迭代，重现开始下次循环迭代。</p>

<h3 id="toc_8">break</h3>

<p><code>break</code> 语句会立即结束整个控制流的执行。</p>

<h2 id="toc_9">带标签的语句</h2>

<p>在 Swift 中，你可以在循环体和 <code>switch</code> 代码块中嵌套循环体和 <code>switch</code> 代码块来创造复杂的控制流结构。然而，循环体和 <code>switch</code> 代码块亮着都可以使用 <code>break</code> 语句来提前结束整个方法。因此，显式地指明 <code>break</code> 语句想要终止是哪个循环体或者 <code>switch</code> 代码块，会很有用。</p>

<p>为了实现这个目的，可以使用标签来标记一个循环体或者 <code>switch</code> 代码块，当使用 <code>break</code> 或者 <code>continue</code> 时，带上这个标签，可以控制该标签代表对象的中断或者执行。</p>

<p>语法：</p>

<pre><code class="language-swift label"></code></pre>

<h2 id="toc_10">提前退出</h2>

<p>像 <code>if</code> 语句一样， <code>guard</code> 的执行取决于一个表达式的布尔值。我们可以使用 <code>guard</code> 语句来要求条件必须为真时，以执行 <code>guard</code> 语句后的代码。不同于 <code>if</code> 语句，一个 <code>guard</code> 语句总是有一个 <code>else</code> 分句，如果条件不为真则执行 <code>else</code> 分句中的代码。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/5/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='technology.html'>Tech</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="http://forrestchang.github.io/14635617646524.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14634546001476.html">
                
                  <h1>Swift 学习笔记：字符串和字符</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">字符串是值类型</h2>

<p>使用字符串会进行值拷贝。</p>

<p>在实际的编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着将字符串作为值类型的同时可以获得极高的性能。</p>

<h2 id="toc_1">Working with Characters</h2>

<p>可以使用 <code>for-in</code> 循环来遍历字符串中的 <code>characters</code> 属性来获取每一个字符的值。</p>

<p>字符串可以通过传递一个值类型为 <code>Character</code> 的数组作为自变量来初始化。</p>

<h2 id="toc_2">连接字符串和字符</h2>

<p>字符串可以通过加法运算符相加在一起创建一个新的字符串。</p>

<p><code>append()</code> 方法可以将一个字符附加到一个字符串变量的尾部。</p>

<h2 id="toc_3">Unicode</h2>

<h3 id="toc_4">Unicode Scalars（Unicode 标量）</h3>

<p>Swift 的 <code>String</code> 类型是基于 Unicode 标量建立的。Unicode 标量是对应字符或者修饰符的唯一的 21 位数字。</p>

<p>Unicode 码位（code poing）的范围是 <code>U+0000</code> 到 <code>U+1F425</code> 或者 <code>U+E000</code> 到 <code>U+10FFFF</code>。Unicode 标量不包括 Unicode 代理项（surrogate pair）码位，其码位范围是 <code>U+D800</code> 到 <code>U+DFFF</code>。</p>

<p>注意，并不是所有的 21 位 Unicode 标量都表示一个字符，因为有一些标量是留作未来分配的。</p>

<h3 id="toc_5">字符串字面量的特殊字符（Special Character in String Literals）</h3>

<p><img src="media/14634546001476/14634553799193.jpg" alt=""/></p>

<h3 id="toc_6">可扩展的字形群集（Extended Grapheme Clusters）</h3>

<p>每一个 Swift 的 Character 类型代表一个可扩展的字形群。一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。</p>

<h3 id="toc_7">计算字符数量</h3>

<p>如果想要获得一个字符串中的 <code>Character</code> 值得数量，可以使用字符串的 <code>characters</code> 属性的 <code>count</code> 属性。</p>

<p>注意在 Swift 中，使用可拓展的字符群集作为 <code>Character</code> 值来连接或改变字符串时，并不一定会更改字符串的字符数量。</p>

<h2 id="toc_8">访问和修改字符串</h2>

<h3 id="toc_9">字符串索引</h3>

<p>使用 <code>startIndex</code> 属性可以获取一个 <code>String</code> 的第一个 <code>Character</code> 的索引。使用 <code>endIndex</code> 属性可以获取最后一个 <code>Character</code> 的后一个位置的索引，所以 <code>endIndex</code> 属性不能作为一个字符串的有效下标。如果 <code>String</code> 是空串，两者是相等的。</p>

<p><code>String.Index.predecessor()</code> 获得前一个索引，<code>successor()</code> 获得后一个索引。</p>

<p><code>Characters</code> 属性的 <code>indices</code> 属性会创建一个包含全部索引的范围（<code>Range</code>），用来在一个字符串中访问单个字符。</p>

<h3 id="toc_10">插入和删除</h3>

<ul>
<li><code>insert(_:atIndex:)</code>：在一个字符串的制定索引插入一个字符</li>
<li><code>insertContentsOf(_:at:)</code>：在一个字符串的指定索引插入一个字符串</li>
<li>`removeAtIndex(_:)：在一个字符串的指定索引删除一个字符</li>
<li><code>removeRange(_:)</code>：在一个字符串的指定索引删除一个子字符串</li>
</ul>

<h2 id="toc_11">比较字符串</h2>

<h3 id="toc_12">字符串/字符相等</h3>

<p>使用 <code>==</code> 和 <code>!=</code> 来比较两个字符/字符串是否相等/不等。</p>

<h3 id="toc_13">前缀/后缀相等</h3>

<ul>
<li><code>hasPrefix(_:)</code></li>
<li><code>hasSuffix(_:)</code></li>
</ul>

<h2 id="toc_14">字符串的 Unicode 表示形式（Unicode Representations of Strings）</h2>

<p>当一个 Unicode 字符串被写进文本文件或其他存储时，字符串中的 Unicode 标量会用 Unicode 定义的几种编码格式（encoding forms）编码。每一个字符串中的小块编码都被称为 <code>code units</code>。这些包括 UTF-8,UTF-16,UTF-32 编码格式。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/5/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='technology.html'>Tech</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="http://forrestchang.github.io/14634546001476.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14631242333306.html">
                
                  <h1>Swift 学习笔记：属性</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>属性将值跟特定的类、结构或枚举关联。存储常量或变量作为实例的一部分，而计算属性（不是存储）一个值。</p>

<ul>
<li>计算属性：类、结构体、枚举</li>
<li>存储属性：类、结构体</li>
</ul>

<h2 id="toc_0">存储属性</h2>

<h3 id="toc_1">延迟存储属性</h3>

<p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 <code>lazy</code> 来标记一个延迟存储属性。</p>

<p>必须将延迟存储属性声明称变量，因为属性的初始值可能在实例构造完成之后才会得到。<strong>而常量属性在构造过程完成之前必须要有初始值，因此无法声明称延迟属性。</strong></p>

<p>延迟属性很有用，当属性的值依赖于在实例的构造过程结束后才会知道影响值得外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它。</p>

<h2 id="toc_2">计算属性</h2>

<p>计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</p>

<h3 id="toc_3">便捷 setter 声明</h3>

<p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 <code>newValue</code>。</p>

<h3 id="toc_4">只读计算属性</h3>

<p>只有 getter 没有 setter 的计算属性就是<strong>只读计算属性</strong>。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</p>

<h2 id="toc_5">属性观察器</h2>

<p>属性观察器监控和响应属性值的变化，每次属性被设置新的值都会调用属性观察器，即使新值和当前值相同的时候也不例外。</p>

<p>可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值得变化。</p>

<ul>
<li><code>willSet</code> 在新的值被设置之前调用</li>
<li><code>didSet</code> 在新的值被设置之后立即调用</li>
</ul>

<p><code>willSet</code> 观察器会将新的属性值作为常量参数传入，在 <code>willSet</code> 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 <code>newValue</code> 表示。</p>

<p><code>didSet</code> 观察器会将旧的属性值作为参数传入，可以为该参数名或者使用默认参数名 <code>oldValue</code>。如果在 <code>didSet</code> 方法中再次对该属性赋值，那么新值会覆盖旧的值。</p>

<p>父类的属性在子类的构造器中被赋值时，它在父类中的 <code>willSet</code> 和 <code>didSet</code> 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。</p>

<p>如果将属性通过 in-out 方式传入函数， <code>willSet</code> 和 <code>didSet</code> 也会被调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。</p>

<h2 id="toc_6">全局变量和局部变量</h2>

<p>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</p>

<p>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记 <code>lazy</code>   修饰符。</p>

<p>局部范围的常量或变量从不延迟计算。</p>

<h2 id="toc_7">类型属性</h2>

<p>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 <code>lazy</code> 修饰符。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/5/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='technology.html'>Tech</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="http://forrestchang.github.io/14631242333306.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14627836147810.html">
                
                  <h1>Swift 学习笔记：集合类型</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型来存储数据合集。数组（Array）是有序数据的集；集合（Sets）是无序无重复数据的集；字典（Dictionaries）是无序的键值对的集。</p>

<p><img src="media/14627836147810/14627837494241.jpg" alt=""/></p>

<h2 id="toc_0">集合的可变性</h2>

<p>在我们不需要改变集合的时候创建不可变集合是很好的实践（使用 <code>let</code>），如此 Swift 编译器可以优化我们创建的集合。</p>

<h2 id="toc_1">数组</h2>

<h3 id="toc_2">创建一个带有默认值的数组</h3>

<p>Swift 中的 Array 类型提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（count）和适当类型的初始值（repeatedValue）传入数组构造函数：</p>

<pre><code class="language-swift">var threeDoubles = [Double](count: 3, repeatedValue: 0.0)
</code></pre>

<h3 id="toc_3">通过两个数组相加创建一个数组</h3>

<p>我们可以使用加法操作符来组合两种已经存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来。</p>

<h3 id="toc_4">访问和修改数组</h3>

<p><code>isEmpty</code> 检查数组是否为空。</p>

<p>使用加法赋值运算符（<code>+=</code>）可以直接在数组后面添加一个或多个拥有相同类型的数据项。</p>

<p>调用数组的 <code>insert(_:atIndex:)</code>方法来在某个具体的索引值之前添加数据项。</p>

<h3 id="toc_5">数组的遍历</h3>

<p>如果我们同事需要每个数据项的值和索引值，可以使用 <code>enumerate()</code> 方法来进行数组遍历。<code>enumerate()</code> 返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历。</p>

<h2 id="toc_6">集合（Sets）</h2>

<p>集合用来存储相同类型且没有确定顺序的值。</p>

<p>Swift 中的 <code>Set</code> 类型被桥接到 <code>Foundation</code> 中的 <code>NSset</code> 类。</p>

<h3 id="toc_7">集合类型的哈希值</h3>

<p>一个类型为了存储在集合中，该类型必须是可哈希化得——也就是说，该类型必须提供一个方法来计算它的哈希值。一个哈希值是 <code>Int</code> 类型的，相等的对象哈希值必须相同，比如<code>a=b</code>，因此必须是<code>a.hashValue = b.hashValue</code>。</p>

<p>Swift 的所有基本类型默认都是可哈希化的，可以作为集合的值类型或者字典的键类型。没有关联值的枚举成员值默认也是可哈希化的。</p>

<p>你可以使用你自定义的类型作为集合的值类型或者是字典的键的类型，但你需要使你的自定义类型符合 Swift 标准库中的 <code>Hashable</code> 协议。符合 <code>Hashable</code> 协议的类型需要提供一个类型为 <code>Int</code> 的可读属性 <code>hashValue</code>。由类型的 <code>hashValue</code> 属性返回的值不需要再同一程序的不同执行周期或者不同程序之间保持相同。</p>

<p>因为 <code>hashValue</code> 协议符合 <code>Equatable</code> 协议，所以符合该协的类型也必须停工一个 <code>==</code> 运算符的实现。这个 <code>Equatable</code> 协议要求任何符合 <code>==</code> 实现的实例间都是一种相等的关系，也就是说，对于 a, b, c 三个值来说，必须满足下面三种情况：</p>

<ul>
<li>自反性：a == a</li>
<li>对称性：a == b, b == a</li>
<li>传递性：a == b &amp;&amp; b == c, a == c</li>
</ul>

<h3 id="toc_8">遍历一个集合</h3>

<p>Swift 中的 <code>Set</code> 类型没有确定的顺序，为了按照特定顺序来遍历一个 <code>Set</code> 中的值可以使用 <code>sort()</code> 方法，它将根据提供的序列返回一个有序集合。</p>

<pre><code class="language-swift">for genre in favoriteGenres.sort() {...}
</code></pre>

<h3 id="toc_9">集合操作</h3>

<p><img src="media/14627836147810/14627853736261.jpg" alt=""/></p>

<p><img src="media/14627836147810/14627854301808.jpg" alt=""/></p>

<p><img src="media/14627836147810/14627854415802.jpg" alt=""/></p>

<h2 id="toc_10">字典</h2>

<p>字典中的数据项并没有具体顺序。</p>

<p>Swift 中 Dictionary 类型被桥接到 Foundation 中的 NSDictionary 类。</p>

<h3 id="toc_11">字典遍历</h3>

<ol>
<li>元组方式</li>
<li>dic.keys</li>
<li>dic.values</li>
</ol>

<p>如果我们只是需要某个字典的键值集合来作为某个接受 Array 实例的 API 的参数，可以直接使用 keys 或 values 属性构造一个新数组。</p>

<pre><code class="language-swift">let airportCodes = [String](airports.keys)
let airportNames = [String](airports.values)
</code></pre>

<p>Swift 的字典类型书无序集合类型。为了以特定的顺序便利字典的键或值，可以对字典的 keys 或 values 属性使用 <code>sort()</code> 方法。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/5/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='technology.html'>Tech</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="http://forrestchang.github.io/14627836147810.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_2.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_4.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="asset/img/avatar.jpg" /></div>
            
                <h1>Hack Notes</h1>
                <div class="site-des"></div>
                <div class="social">







<a target="_blank" class="weibo" href="http://weibo.com/tisoga" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="https://twitter.com/Tisoga" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="https://github.com/forrestchang" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:forrestchang7@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="life.html"><strong>Life</strong></a>
        
            <a href="machine-learning.html"><strong>ML</strong></a>
        
            <a href="python.html"><strong>Python</strong></a>
        
            <a href="productivity.html"><strong>Productivity</strong></a>
        
            <a href="technology.html"><strong>Tech</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14832795759469.html">2017 Week 1 Review</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14827163208652.html">2016 Week 52 Review</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14824086421976.html">推荐系统笔记</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14824103542982.html">2016 Week 51 Review</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14824081615573.html">2016 Week 46 Review</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>


<script type="text/javascript">
    var disqus_shortname = 'tisogasnotes'; 

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<script type="text/javascript">
var disqus_shortname = 'tisogasnotes'; 

(function () {
var s = document.createElement('script'); s.async = true;
s.type = 'text/javascript';
s.src = '//' + disqus_shortname + '.disqus.com/count.js';
(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>
<script>
                            var _hmt = _hmt || [];
                            (function() {
                                    var hm = document.createElement("script");
                                    hm.src = "https://hm.baidu.com/hm.js?001e800887eba2f8f57ec8059aafdad6";
                                    var s = document.getElementsByTagName("script")[0];
                                    s.parentNode.insertBefore(hm, s);
                                    })();
                            </script>

  </body>
</html>
