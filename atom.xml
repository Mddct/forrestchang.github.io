<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Hack Notes]]></title>
  <link href="http://forrestchang.github.io/atom.xml" rel="self"/>
  <link href="http://forrestchang.github.io/"/>
  <updated>2017-01-13T19:36:53+08:00</updated>
  <id>http://forrestchang.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[2017 Week 1 Review]]></title>
    <link href="http://forrestchang.github.io/14832795759469.html"/>
    <updated>2017-01-01T22:06:15+08:00</updated>
    <id>http://forrestchang.github.io/14832795759469.html</id>
    <content type="html"><![CDATA[
<p>今天是元旦，因为在 Calendar 中把今天归到 2017 年的第一周里了，所以就按照上面所写的把这周当做第一周吧。</p>

<p>这周结束了在中软的课程设计实训，以前总嫌弃小渔村破，现在回来才知道还是小渔村好啊。课程设计实训的内容是用 Java 写一个点餐系统，一个小组只需要做一份就可以了，不过几乎所有人都不知道 Git 是个什么东西，小组合作还是用的 U 盘拷贝代码，所以代码质量可想而知了，本组的其他人都比较厉害，索性我就抱大腿划水了，什么也没有参与，代码也没有写一行。</p>

<p>不过虽说没有写课程设计的项目，但还是有写代码的。这周把两个月前参加 HACKxFDU 的项目拿出来用 Python 3 重写了一遍。项目的地址：<a href="https://github.com/forrestchang/Neutron">Neutron</a>，当初我们考虑做 Neutron 的时候是想把它做成一个通用的智能家居语音终端的，类似于 Amazon 的 Echo，只要提供第三方的 API，就能轻松集成到 Neutron 来，但是实际上碍于 Hackathon 的时间限制，只是完成了一个简单的 Demo，完全没有拓展性。本来这个项目参加完 Hackathon 之后就没有管了，不过最近看到 Facebook CEO 扎克伯格写了一个 Jarvis，觉得和之前做的东西很像（当然还是差远了，基本我们做的东西就是用别人的 API），所以又掏出来拿 Python 3.5 重写了一遍。现在在 <a href="https://github.com/forrestchang/neutron/tree/develop">develop</a> 分支基本上把框架搭建好了，最底层是和 API 交互的 layer 层，这一层需要为每个 API 写特定的代码，其上是抽象的 handler 层，提供通用的接口，抽象 layer 层的操作：例如语音控制模块、AI 模块等，这一层上还可能包裹一层特定的 wrapper，例如对特定的 message 做语义分析。通过配置文件来选择使用哪个 layer 以及配置 layer 的内容（key 等内容），开始的时候打算用 json 来做配置文件的，后来看了一下还有 yaml 这种更加简洁的配置文件，所以打算换成 yaml 的。目前这个项目还有很多内容要写的，比如特定的 layer，都需要更具不同的 API 写特定的代码，这一点上我参考的 <a href="https://github.com/syl20bnr/spacemacs">Spacemacs</a> 的方法。</p>

<p>这周在中软那边的宿舍里面把08版的《射雕英雄传》看完了，虽然槽点挺多的（特效、台词、演技），但是还是看得很欢乐，林依晨的黄蓉甚是喜欢。记得以前应该是看过朱茵版的黄蓉的，不过时间太久远了，已经记不太清了。小说倒没有读完，还是看剧比较快啊。看完后好长一段时间里面都觉得特别空虚，总感觉少了些什么。这种孤独感几乎在每次看完某部小说和电视剧后都会有（电影倒没有这种感觉，可能时间太短了），总觉得还沉浸在别人的故事里，可惜别人的故事已经结束，不得不回到现实中来。想起席慕蓉的一句话『在别人的故事里，留着自己的泪』 <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> 。</p>

<hr/>

<p>就借着这篇博客顺便说说 17 年的计划吧。</p>

<ol>
<li>学习一门新语言：14年学了 C、Scheme，15年学了 Java、Python，16年学了 Swift，再加上各种用过但是不熟的语言，也有好多个了。现在主力开发语言是 Python，17年打算学习 一下 JavaScript，这门 GitHub 上最火的语言，不会都不好意思说自己是程序员。也不用学到多么深，只求达到入门水平。</li>
<li>Python 水平达到 professional，用了接近两年的 Python，但是水平也没有长进多少，今年打算深入一下 Python，多写一些项目。</li>
<li>去周边国家玩一次，其实挺想去尼泊尔的，不知道今年有没有时间。不过即使不出国，也要多出去走走，一个人的旅行。</li>
</ol>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>席慕蓉的《戏子》，用在这里并不完全准确。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 52 Review]]></title>
    <link href="http://forrestchang.github.io/14827163208652.html"/>
    <updated>2016-12-26T09:38:40+08:00</updated>
    <id>http://forrestchang.github.io/14827163208652.html</id>
    <content type="html"><![CDATA[
<p>2016 年最后一周（实际上还有6天，不过那一周就算到 2017 年第一周吧）。</p>

<ul>
<li><strong>编程</strong>：这周在看《Python 网络数据采集》，以前虽然也用过爬虫，但是毕竟没有系统地学过，所以还是找了一本书来看。但是说实话，这本书写得并不是很好，不知道是写书时间的原因还是什么，挺多语法错误的，而且代码的风格很差（完全不符合 PEP8 标准）。内容也比较浅，基本上都是之前已经知道了的东西，所以收获也不是很多，（下一篇的博客可以来写一写怎么写一个高效的爬虫）。面试的事情作废了，1）看了一下他们做的产品，感觉不是自己想要做的东西；2）开出的薪资太低，up to 2k（其实主要是薪资太低了，每天要往返金石滩和大连市，太累了）。所以还是好好学习准备明年的暑期实习吧。另外 GSoC 也应该放上日程了，即使有申请不上的可能，还是要试一试的。</li>
<li><strong>阅读</strong>：开始读金庸的《射雕英雄传》，以前上学的时候一直被家里教导不要沉迷武侠小说，所以一直没有读过金庸和古龙（然而那些时间都用来看网文玄幻了……）。最近读来还是觉得很有意思，作为实训的时候消遣很不错（主要没有网）。</li>
<li><strong>生活</strong>：这周五就可以离开这鬼地方了，见识过外包公司的情况后决定以后肯定是不会进这种公司的。在公司里实训也一直没有写代码，本来打算用 Python 实现一下实训的题目的，但是老师说不允许，这也没什么办法，索性就划水吧。</li>
<li><strong>博客</strong>：可以看到，我博客又换样子了。用 Emacs 来写博客还是太麻烦了一些，而且 render 的速度实在是太感人，本地的 org 文件多了之后好几次 render 的时候卡住。现在这个博客是 Mweb 自带的 generator 生成的，就是主题不怎么好看，其他的都很方便。奈何自己的前端知识太渣，改了半天也没有改成自己想要的样子，所以还是凑合着先用吧。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐系统笔记]]></title>
    <link href="http://forrestchang.github.io/14824086421976.html"/>
    <updated>2016-12-22T20:10:42+08:00</updated>
    <id>http://forrestchang.github.io/14824086421976.html</id>
    <content type="html"><![CDATA[
<p>开始学习机器学习/数据挖掘相关的内容，打算每学习一部分知识就写一篇博客总结一下，当做学习过程中的笔记，也为以后看的时候提供存档。</p>

<p>这一篇笔记是关于推荐系统的，主要讲了两种推荐算法（基于用户和基于物品的协同过滤）。</p>

<h2 id="toc_0">基于用户的协同过滤</h2>

<h3 id="toc_1">协同过滤（Collaborative filtering）</h3>

<p>一个协作型过滤算法通常的做法是对一大群人进行搜索，并从中找出与我们品味相近的一小群人。算法会对这些人所偏爱的其他内容进行考察，并将它们组合起来构造出一个经过排名的推荐列表。</p>

<h3 id="toc_2">测试数据集</h3>

<p>为了演示一些算法，我们需要从<a href="http://grouplens.org/datasets/movielens/">这个网站</a>上下载一份数据集。这里因为是作为演示使用，所以只需要下载<a href="http://files.grouplens.org/datasets/movielens/ml-latest-small.zip">ml-latest-small.zip</a>这一份简单的数据集就可以了。</p>

<h3 id="toc_3">相似度计算</h3>

<p>在有了数据之后，我们需要有一种方法来确定人们在品味方面的相似程度。为此，我们可以将每个人与所有其他人进行对比，并计算他们的<strong>相似度评价值</strong>。</p>

<h4 id="toc_4">欧几里德距离评价（Euclidean Distance Score）</h4>

<p>欧几里德距离是指多维空间中两点间的距离，这是一种用直尺测量出来的距离。如果我们将两个点分别记作\((p_1, p_2, p_3, p_4, ...)\)和\((q_1, q_2, q_3, q_4, ...)\)，则欧几里德距离的计算公式为：</p>

<p>\[<br/>
\sqrt{((p_1-q_1)^2+(p_2-q_2)^2+...+(p_n-q_n)^2)} = \sqrt{(\sum_{i=1}^n(p_i-q_i)^2)}<br/>
\]</p>

<p>创建 <code>recommendations.py</code>。</p>

<p>用代码表示：</p>

<pre><code class="language-python">from math import sqrt

# 返回一个有关 person1 与 person2 的基于距离的相似度评价
def sim_distance(prefs, person1, person2):
    # 得到 shared_items 的列表
    shared_items = {}
    for item in prefs[person1]:
        if item in prefs[person2]:
        shared_items[item] = 1
    
    # 如果两者没有共同之处，则返回 0
    if len(shared_items) == 0:
        return 0
        
    # 计算所有差值的平方和
    sum_of_squares = sum([pow(prefs[person1][item]-prefs[person2][item], 2)for item in prefs[person1] if item in prefs[person2]])
    
    return 1 / (1 + sqrt(sum_of_squares))
</code></pre>

<p>欧几里德距离计算公式可以计算出距离值，偏好越相似的人，其距离就越短。不过，我们还需要一个函数，来对偏好越相近的情况给出越大的值，为此，我们可以将函数的值加 1（这样就可以避免遇到被 0 整除的错误了），并取其倒数，入上面代码最后一行所示。</p>

<p>好了，现在我们需要先将数据读取进来，在 <code>recommendations.py</code> 中添加如下代码:</p>

<pre><code class="language-python">def loadMovieLens(path=&#39;data&#39;):
    movies = {}
    for line in open(path + &#39;/movies.csv&#39;):
        (id, title) = line.split(&#39;,&#39;)[0:2]
        movies[id] = title

    prefs = {}
    for line in open(path+&#39;/ratings.csv&#39;):
        (user, movieid, rating, ts) = line.split(&#39;,&#39;)
        prefs.setdefault(user, {})
        prefs[user][movies[movieid]] = float(rating)
    return prefs
</code></pre>

<p>在 ipython 交互环境中：</p>

<pre><code class="language-python">&gt;&gt;&gt; import recommendations
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; # 比较 10 号用户 和 20 号用户的相似度评价
&gt;&gt;&gt; recommendations.sim_distance(prefs, &#39;10&#39;, &#39;20&#39;)
0.23371479611805132
</code></pre>

<h4 id="toc_5">皮尔逊相关系数（Pearson Correlation Coefficient）</h4>

<p>皮尔逊相关系数是一种度量两个变量间相关程度的方法，它是一个介于 1 和 -1 之间的值，其中，1 表示变量完全正相关，0 表示无关， -1 则表示完全负相关（一个变量的值越大，则另一个变量的值反而会越小）。</p>

<p>计算公式：</p>

<p>\[<br/>
r = \frac{\sum{XY}-\frac{\sum X \sum Y}{N}}{\sqrt{(\sum X^2 - \frac{(\sum X)^2}{N})(\sum Y^2 - \frac{(\sum Y)^2}{N})}}<br/>
\]</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python">def sim_pearson(prefs, person1, person2):
      # 得到双方都曾评价过的物品列表
    shared_items = {}
    for item in prefs[person1]:
        if item in prefs[person2]:
            shared_items[item] = 1
      # 得到物品列表元素的个数
    n = len(shared_items)

      # 如果两者没有共同元素，则返回0
    if n == 0:
        return 0

      # 计算 person1 和 person2 的皮尔逊相关系数
    sumxy = sum([prefs[person1][item] * prefs[person2][item]
                for item in shared_items])
    sumx = sum([prefs[person1][item] for item in shared_items])
    sumy = sum([prefs[person2][item] for item in shared_items])
    sumx2 = sum([prefs[person1][item] ** 2 for item in shared_items])
    sumy2 = sum([prefs[person2][item] ** 2 for item in shared_items])

    zahler = sumxy - (sumx * sumy) / n
    nenner = sqrt((sumx2 - (sumx ** 2) / n) * (sumy2 - (sumy ** 2) / n))
    if nenner == 0:
        return 0
    r = zahler / nenner

    return r
</code></pre>

<p>在 ipython 交互环境中：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; recommendations.sim_pearson(prefs, &#39;10&#39;, &#39;20&#39;)
0.4908806936738162
</code></pre>

<p>可以看到和上面使用欧几里德距离评价计算出来的相似度是不一样的。</p>

<h4 id="toc_6">关于该使用哪一种相似性度量方法</h4>

<p>除了这两种计算相似度的方法，实际上还有许多别的计算相似度的算法，例如<strong>Tanimoto 分值</strong>。使用哪一种方法，完全取决于具体的应用。</p>

<p>下面的代码中，将使用一个通用的相似性函数来计算相似度，只要它满足以下条件：拥有同样的函数签名，以一个浮点数作为返回值，其数值越大代表相似度越大。</p>

<h3 id="toc_7">寻找相似的用户</h3>

<p>既然我们已经有了对两个人进行比较的函数，下面我们就可以编写，根据指定人员对每个人进行打分，并找出最接近的匹配结果了。</p>

<pre><code class="language-python"># 从反映偏好的字典中返回最佳匹配者
# 返回结果的个数和相似度函数均为可选参数
def topMatches(prefs, person, n=5, similarity=sim_pearson):
    scores = [(similarity(prefs, person, other), other) for other in prefs if other != person]
    
    # 对列表进行排序，评价值最高者排在最前面
    scores.sort(reverse=True)
    return scores[:n]
</code></pre>

<p>在 ipython 交互环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; # 与 40 号用户相似的 10 个用户
&gt;&gt;&gt; recommendations.topMatches(prefs, &#39;40&#39;, n=10)
[(1.0, &#39;63&#39;),
 (1.0, &#39;582&#39;),
 (1.0, &#39;326&#39;),
 (1.0, &#39;260&#39;),
 (1.0, &#39;220&#39;),
 (1.0, &#39;198&#39;),
 (1.0, &#39;153&#39;),
 (1.0, &#39;116&#39;),
 (0.9999999999999947, &#39;474&#39;),
 (0.9999999999999947, &#39;215&#39;)]
</code></pre>

<h3 id="toc_8">推荐物品</h3>

<p>有的时候我们可能不需要寻找相似的用户，例如在购物网站中，我们需要的是一份可能会想要购买的物品列表，一种方法是从相似的用户所购买的物品列表中选出没有购买的，但是这种方法不确定的因素太多，例如可能相似用户还未购买某些物品，而这些物品恰恰就是我们所需要的。</p>

<p>为了解决上面的问题，我们需要通过一个经过加权的评价值来为影片打分，评论者的评分结果因此而形成了先后的排名。为此，我们需要取得所有其他评论者的评价结果，借此得到相似度之后，再乘以他们为每部影片所给的评价值。</p>

<p>以以下数据集为例：</p>

<pre><code>{&#39;Lisa Rose&#39;: {&#39;Lady in the Water&#39;: 2.5,
               &#39;Snakes on a Plane&#39;: 3.5,
               &#39;Just My Luck&#39;: 3.0,
               &#39;Superman Returns&#39;: 3.5,
               &#39;You, Me and Dupree&#39;: 2.5,
               &#39;The Night Listener&#39;: 3.0},
 &#39;Gene Seymour&#39;: {&#39;Lady in the Water&#39;: 3.0,
                  &#39;Snakes on a Plane&#39;: 3.5,
                  &#39;Just My Luck&#39;: 1.5,
                  &#39;Superman Returns&#39;: 5.0,
                  &#39;The Night Listener&#39;: 3.0,
                  &#39;You, Me and Dupree&#39;: 3.5},
 &#39;Michael Phillips&#39;: {&#39;Lady in the Water&#39;: 2.5,
                      &#39;Snakes on a Plane&#39;: 3.0,
                      &#39;Superman Returns&#39;: 3.5,
                      &#39;The Night Listener&#39;: 4.0},
 &#39;Claudia Puig&#39;: {&#39;Snakes on a Plane&#39;: 3.5,
                  &#39;Just My Luck&#39;: 3.0,
                  &#39;The Night Listener&#39;: 4.5,
                  &#39;Superman Returns&#39;: 4.0,
                  &#39;You, Me and Dupree&#39;: 2.5},
 &#39;Mick LaSalle&#39;: {&#39;Lady in the Water&#39;: 3.0,
                  &#39;Snakes on a Plane&#39;: 4.0,
                  &#39;Just My Luck&#39;: 2.0,
                  &#39;Superman Returns&#39;: 3.0,
                  &#39;The Night Listener&#39;: 3.0,
                  &#39;You, Me and Dupree&#39;: 2.0},
 &#39;Jack Matthews&#39;: {&#39;Lady in the Water&#39;: 3.0,
                   &#39;Snakes on a Plane&#39;: 4.0,
                   &#39;The Night Listener&#39;: 3.0,
                   &#39;Superman Returns&#39;: 5.0,
                   &#39;You, Me and Dupree&#39;: 3.5},
 &#39;Toby&#39;: {&#39;Snakes on a Plane&#39;: 4.5,
          &#39;You, Me and Dupree&#39;: 1.0,
          &#39;Superman Returns&#39;: 4.0}}
</code></pre>

<p>假设我们需要给 Toby 提供影片推荐，我们可以根据上面的算法得出一张表：</p>

<table>
<thead>
<tr>
<th>评论者</th>
<th>相似度</th>
<th>Night</th>
<th>S.xNight</th>
<th>Lady</th>
<th>S.xLady</th>
<th>Luck</th>
<th>S.xLuck</th>
</tr>
</thead>

<tbody>
<tr>
<td>Rose</td>
<td>0.99</td>
<td>3.0</td>
<td>2.97</td>
<td>2.5</td>
<td>2.48</td>
<td>3.0</td>
<td>2.97</td>
</tr>
<tr>
<td>Seymour</td>
<td>0.38</td>
<td>3.0</td>
<td>1.14</td>
<td>3.0</td>
<td>1.14</td>
<td>1.5</td>
<td>0.57</td>
</tr>
<tr>
<td>Puig</td>
<td>0.89</td>
<td>4.5</td>
<td>4.02</td>
<td></td>
<td></td>
<td>3.0</td>
<td>2.68</td>
</tr>
<tr>
<td>LaSalle</td>
<td>0.92</td>
<td>3.0</td>
<td>2.77</td>
<td>3.0</td>
<td>2.77</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Matthews</td>
<td>0.66</td>
<td>3.0</td>
<td>1.99</td>
<td>3.0</td>
<td>1.99</td>
<td></td>
<td></td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td></td>
<td>12.89</td>
<td></td>
<td>8.38</td>
<td></td>
<td>8.07</td>
</tr>
<tr>
<td>Sim.Sum</td>
<td></td>
<td></td>
<td>3.84</td>
<td></td>
<td>2.95</td>
<td></td>
<td>3.18</td>
</tr>
<tr>
<td>总计/Sim.Sum</td>
<td></td>
<td></td>
<td>3.35</td>
<td></td>
<td>2.83</td>
<td></td>
<td>2.53</td>
</tr>
</tbody>
</table>

<p>表中列出来每位评论者的相关度评价值，以及他们对三部影片的评分情况。以 S.x 打头的列给出了乘以评价值之后的相似度。如此一来，相比于与我们不相近的人，那些与我们相近的人将会对整体评价拥有更多的贡献。总计所有加权评价值的和。</p>

<p>我们也可以选择利用总计值来计算排名，但是这其中有一个问题，一部受更多人评论的影片会对结果产生很大影响。为了修正这一问题，我们需要除以表总名为 Sim.Sum 的那一行，它代表了<strong>所有对这部电影有过评论的评论者的相似度之和</strong>。对于影片《Lady in the Water》来说，Puig 并未做过评论，所以我们将这部影片的总计值除以所有其他人的相似度之和。</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python"># 利用所有其他人评价值得加权平均，为某人提供建议
def getRecommendations(prefs, person, similarity=sim_pearson):
    totals = {}
    simSums = {}
    for other in prefs:
        # 不要和自己做比较
        if other == person:
            continue
        sim = similarity(prefs, person, other)
        
        # 忽略评价值为零或者小于零的情况
        if sim &lt;= 0:
            continue
            
        for item in prefs[other]:
            # 只对自己还未看过的影片进行评价
            if item not in prefs[person] or prefs[person][item] == 0:
                # 相似度*评价值
                totals.setdefault(item, 0)
                totals[item] += prefs[other][item] * sim
                # 相似度之和
                simSums.setdefault(item, 0)
                simSums[item] += sim
        
        # 建立一个归一化的列表
        rankings = [(total / simSums[item], item) for item, total in totals.items()]
        
        # 返回经过排序的列表
        rankings.sort(reverse=True)
        return rankings
</code></pre>

<p>在 ipython 中测试一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; relaod(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; recommendations.getRecommendations(prefs, &#39;10&#39;)[:20]
[(5.000000000000001,
  &#39;The Slipper and the Rose: The Story of Cinderella (1976)&#39;),
 (5.000000000000001, &#39;Hands on a Hard Body (1996)&#39;),
 (5.000000000000001, &#39;For the Birds (2000)&#39;),
 (5.000000000000001, &#39;Diva (1981)&#39;),
 (5.0, &#39;Zorba the Greek (Alexis Zorbas) (1964)&#39;),
 (5.0, &#39;Zerophilia (2005)&#39;),
 (5.0, &#39;Zelary (2003)&#39;),
 (5.0, &#39;Z Channel: A Magnificent Obsession (2004)&#39;),
 (5.0, &#39;Yossi (Ha-Sippur Shel Yossi) (2012)&#39;),
 (5.0, &#39;World of Tomorrow (2015)&#39;),
 (5.0, &#39;Woody Allen: A Documentary (2012)&#39;),
 (5.0, &#39;Woman on Top (2000)&#39;),
 (5.0, &#39;Without a Clue (1988)&#39;),
 (5.0, &#39;Withnail &amp; I (1987)&#39;),
 (5.0, &#39;Wild Zero (2000)&#39;),
 (5.0, &#39;War Room (2015)&#39;),
 (5.0, &#39;Walker (1987)&#39;),
 (5.0, &#39;Voices from the List (2004)&#39;),
 (5.0, &#39;Videodrome (1983)&#39;),
 (5.0, &#39;Victoria (2015)&#39;)]
</code></pre>

<h3 id="toc_9">匹配商品</h3>

<p>现在我们已经可以为指定人员寻找品味相近的用户，以及如何向其推荐商品。假如我们想要了解哪些物品是相近的，那又该如何呢？</p>

<p>在我们浏览 Amazon 的时候，经常会看到页面底部会推荐与当前浏览的物品相似的商品。这种情况，我们可以通过查看哪些人喜欢某一特定物品，以及这些人喜欢哪些其他物品来决定相似度。事实上，这和我们之前用来计算人与人之间的相似度是一样的，只需要把人和物品相互调换就行了。</p>

<p>我们来编写这个翻转字典的函数：</p>

<pre><code class="language-python">def transformPrefs(prefs):
    result = {}
    for person in prefs:
        for item in prefs[person]:
            result.setdefault[item, {}]
            # 将物品和人对调
            result[item][person] = prefs[person][item]
    return result
</code></pre>

<p>有了这个方法之后，我们就可以复用之前所写的方法了。</p>

<p>在 ipython 环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; load(recommendations)
&gt;&gt;&gt; movies = recommendations.transformPrefs()
&gt;&gt;&gt; recommendations.topMatches(movies, &#39;For the Birds (2000)&#39;)
[(1.000000000000016, &#39;&quot;Silence of the Lambs&#39;),
 (1.0, &#39;World War Z (2013)&#39;),
 (1.0, &#39;Wallace &amp; Gromit in The Curse of the Were-Rabbit (2005)&#39;),
 (1.0, &#39;Tron: Legacy (2010)&#39;),
 (1.0, &#39;Transcendence (2014)&#39;)]
</code></pre>

<p>我们还可以为影片推荐评论者：</p>

<pre><code class="language-python">&gt;&gt;&gt; recommendations.getRecommendations(movies, &#39;For the Birds (2000)&#39;)[:20]
[(5.0, &#39;668&#39;),
 (5.0, &#39;618&#39;),
 (5.0, &#39;543&#39;),
 (5.0, &#39;541&#39;),
 (5.0, &#39;536&#39;),
 (5.0, &#39;52&#39;),
 (5.0, &#39;464&#39;),
 (5.0, &#39;46&#39;),
 (5.0, &#39;409&#39;),
 (5.0, &#39;357&#39;),
 (5.0, &#39;308&#39;),
 (5.0, &#39;296&#39;),
 (5.0, &#39;29&#39;),
 (5.0, &#39;28&#39;),
 (5.0, &#39;197&#39;),
 (5.0, &#39;196&#39;),
 (5.0, &#39;190&#39;),
 (5.0, &#39;131&#39;),
 (5.0, &#39;113&#39;),
 (4.999999999999999, &#39;465&#39;)]
</code></pre>

<h2 id="toc_10">基于物品的协同过滤</h2>

<p>当前所完成的推荐系统，要求我们使用每一位用户的全部评分来构建数据集，这种方法对于小规模的数据集是没有问题的，但是对于像 Amazon 这样有着上百万用户和商品的大型网站而言，讲一个用户同其他所有用户进行比较，然后再对每位用户评过分的商品进行比较，时间花费上是巨大的。</p>

<p>目前为止我们所使用的技术被称为<strong>基于用户的协同过滤</strong>（user-based collaborative filtering）。除此以外，还有一种可供选择的方法被称为<strong>基于物品的协同过滤</strong>（item-based collaborative filtering）。在拥有大量数据集的情况下，基于物品的协同过滤能够得出更好的结论，而且它允许我们将大量的计算任务预先执行，从而使需要给予推荐的用户能够更快地得到他们所要的结果。</p>

<p>基于物品的协同过滤总体思路就是为每件物品预先计算好最为相近的其他物品。然后，当我们想为某位用户提供推荐的时候，就可以查看他曾经评过分的物品，并从中选出排名靠前者，再构造一个加权列表，其中包含了与这些选中物品最相近的其他物品。此处最显著的区别在于，尽管第一步要求我们检查所有的数据，但是物品间的比较不会像用户间比较那么频繁变化。</p>

<h3 id="toc_11">构造物品比较数据集</h3>

<p>为了对物品进行比较，我们要做的第一件事就是编写一个函数，构造一个包含相近物品的完整数据集。构建完数据集之后，我们就可以在需要的时候重复使用它。</p>

<p>将下面代码添加到 <code>recommendations.py</code> 中：</p>

<pre><code class="language-python">def calculateSimilarItems(prefs, n=10):
    # 建立字典，以给出与这些物品最为相近的其他物品
    result = {}
    
    # 以物品为中心最偏好矩阵进行倒置处理
    itemPrefs = transformPrefs(prefs)
    c = 0
    for item in itemPrefs:
        # 针对大数据集更新状态变量
        c += 1
        if c % 100 == 0:
            print &quot;%d / %d&quot; % (c, len(itemPrefs))
        scores = tomMatchs(itemPrefs, item, n=n, similarity=sim_pearson)
        result[item] = scores
    return result
</code></pre>

<p>该函数首先利用了此前定义过得 <code>transformPrefs</code> 函数，对反映评价的字典进行倒置处理，从而得到一个有关物品及其用户评价情况的列表，然后程序又循环遍历每项物品，并将转换了的字典传入 <code>tomMatches</code> 函数中，求得最为相近的物品及其相似度评价值，最后，它建立并返回了一个包含物品及其最相近物品列表的字典。</p>

<p>在 ipython 交互环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; itemsim = recommendations.calculateSimilarItems(prefs)
100 / 8963
200 / 8963
300 / 8963
400 / 8963
500 / 8963
600 / 8963
700 / 8963
800 / 8963
900 / 8963
1000 / 8963
1100 / 8963
1200 / 8963
1300 / 8963
1400 / 8963
1500 / 8963
1600 / 8963
1700 / 8963
1800 / 8963
1900 / 8963
...
</code></pre>

<p>首次运行需要等待一段时间进行计算。</p>

<p>只有频繁执行该函数，才能令物品的相似度不至于过期。通常我们需要在用户基数和评分数量不是很大的时候执行这一函数，但是随着用户数量的不断增长，物品间的相似度评价通常会变得越来越稳定。</p>

<h3 id="toc_12">获得推荐</h3>

<p>现在，我们可以利用反映物品相似度的字典来给出推荐了，我们可以去到用户评价过得所有物品，并找出其相近的物品，根据相似度对其进行加权。</p>

<p>下表给出了利用基于物品的方法寻找推荐的过程，所用到的数据可以在上面<strong>推荐物品</strong>一节中找到。</p>

<p>为 Toby 提供基于物品的推荐：</p>

<table>
<thead>
<tr>
<th>影片</th>
<th>评分</th>
<th>Night</th>
<th>R.xNight</th>
<th>Lady</th>
<th>R.xLady</th>
<th>Luck</th>
<th>R.xLuck</th>
</tr>
</thead>

<tbody>
<tr>
<td>Snakes</td>
<td>4.5</td>
<td>0.182</td>
<td>0.818</td>
<td>0.222</td>
<td>0.999</td>
<td>0.105</td>
<td>0.474</td>
</tr>
<tr>
<td>Superman</td>
<td>4.0</td>
<td>0.103</td>
<td>0.412</td>
<td>0.091</td>
<td>0.363</td>
<td>0.065</td>
<td>0.258</td>
</tr>
<tr>
<td>Dupree</td>
<td>1.0</td>
<td>0.148</td>
<td>0.148</td>
<td>0.4</td>
<td>0.4</td>
<td>0.182</td>
<td>0.182</td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td>0.433</td>
<td>1.378</td>
<td>0.713</td>
<td>1.762</td>
<td>0.352</td>
<td>0.914</td>
</tr>
<tr>
<td>归一化结果</td>
<td></td>
<td></td>
<td>3.183</td>
<td></td>
<td>2.473</td>
<td></td>
<td>2.598</td>
</tr>
</tbody>
</table>

<p>此处每一行都列出了一部我们曾经观看过的影片，以及对该片的个人评价。对于每一部我们还未曾看过的影片，相应有一列会指出它与已观看影片的相似程度。以 R.x 打头的列给出了我们队影片的评价值乘以相似度之后的结果。</p>

<p>总计一行给出了每部影片相似度评价值的总和以及 R.x 列的总和，为了预测我们对每一部影片的评分情况，只要将 R.x 列的总计值除以相似度一列的总计值即可。</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python">def getRecommendedItems(prefs, itemMatch, user):
    userRatings = prefs[user]
    scores = {}
    totlaSim = {}
    
    # 循环遍历由当前用户评分的物品
    for (item, rating) in userRatings.items():
        
        # 循环遍历与当前物品相近的物品
        for (similarity, item2) in itemMatch[item]:
        
            # 如果该用户已经对当前物品做过评价，则将其忽略
            if item2 in userRatings:
                continue
            
            # 评价值与相似度加权之和
            scores.setdefault(item2, 0)
            scores[item2] += similarity * rating
            
            # 全部相似度之和
            totalSim.setdefault(item2, 0)
            totalSim[item2] += similarity
            
    # 将每个合计值除以加权和，求出平均值
    rankings = [(score / totalSim[item], item) for item, score in scores.items()]
    
    # 按最高值到最低值的顺序，返回评分结果
    rankings.sort(reverse=True)
    return rankings
</code></pre>

<p>在 ipython 中测试一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; recommendations.getRecommendedItems(prefs, itemsim, &#39;20&#39;)[:10]
[(5.0, &#39;Zoot Suit (1981)&#39;),
 (5.0, &#39;Zoolander (2001)&#39;),
 (5.0, &#39;Zack and Miri Make a Porno (2008)&#39;),
 (5.0, &quot;You&#39;ve Got Mail (1998)&quot;),
 (5.0, &#39;X-Men: The Last Stand (2006)&#39;),
 (5.0, &#39;X-Men: Apocalypse (2016)&#39;),
 (5.0, &#39;X-Men (2000)&#39;),
 (5.0, &quot;Von Ryan&#39;s Express (1965)&quot;),
 (4.75, &#39;Willow (1988)&#39;),
 (4.75, &quot;White Men Can&#39;t Jump (1992)&quot;)]
</code></pre>

<h2 id="toc_13">基于用户进行过滤还是基于物品进行过滤</h2>

<p>在数据集大小上，基于物品进行过滤的方式要比基于用户进行过滤更快；在数据的稀疏程度上，稀疏的数据集使用基于物品的过滤方法更优，而对于秘密集的数据集而言，两者的效果几乎一样。</p>

<p>基于用户的过滤方法更加易于实现，而且无需额外步骤，因此它通常更适用于规模较小的变化非常频繁的数据集。在一些应用中，告诉用户还有哪些人与自己有着相近偏好是有一定价值的——也许对于一个购物网站而言，我们并不想这么做，但是对于一个音乐分享类或者电影评分类网站而言，这种潜在的需求却是存在的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 51 Review]]></title>
    <link href="http://forrestchang.github.io/14824103542982.html"/>
    <updated>2016-12-22T20:39:14+08:00</updated>
    <id>http://forrestchang.github.io/14824103542982.html</id>
    <content type="html"><![CDATA[
<p>看了一下日历，上一周是 2016 年的倒数第二周了（写这篇文章的时候已经是 52 周了），换了新博客之后就一直没有再写过 Week Review，这其中虽然有一些外部的因素，但大抵上还是不想写。</p>

<p>上周学校组织来中软做课程设计，所以这些天一直待在中软的培训中心里，课程设计的题目是一个点餐的 Web 应用，用 Java 开发，因为并不打算从事 Java，所以也并没有怎么听，大部分时间都是在自己看书和写自己的 Project。不过要吐槽一下这边的环境，宿舍除了床什么也没有，所以晚上回去什么都干不了，只能坐在床上看看电影，最不能忍的是网都没有……学校送来培训中心的这种做法我是很不认同的，好好的大学为什么要搞成职业教育呢？</p>

<p>最近找到了大连的一家做 Python Web 的 start up，联系了一下准备过去面试，不过软件园离学校太远了，估计面过了也不会去吧。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 46 Review]]></title>
    <link href="http://forrestchang.github.io/14824081615573.html"/>
    <updated>2016-12-22T20:02:41+08:00</updated>
    <id>http://forrestchang.github.io/14824081615573.html</id>
    <content type="html"><![CDATA[
<p>编程学习方面，不完全看完了《利用 Python 进行数据分析》，感觉光看没有进行练习的话很难一次记住那么多用法，所以这本书最好还是最 NumPy、Pandas 这几个库用过一段时间之后再看。之后开始看《集体智慧编程》，目前才看了两章，内容写得还是挺好的，不过很多代码不是很规范（比如命名、缩进什么的），还有就是可能书已经比较老了，很多例子中使用的 API 已经挂掉了，所以不得不自己找数据集下来测试。不知道别人看书是怎样的，反正我看书不把书中每个例子测试一下就感觉书好像没看过，所以看书的速度还是挺慢的，昨天和今天花了两天的时间把第2章的东西总结了一下，写了篇博客。</p>

<p>朋友说我现在才开始学习机器学习并且想要以此为以后的职业简直在玩火（并且还不打算读研究生的情况下），说得也是，毕竟现在已经大三了，按照道理，应该刷刷题准备下学期的实习面试的。不过既然跳进这个火坑里了，就不能半途而废，至少先学习几个月看看情况再变更计划。如果实在不行，到时候再去做 Web 开发还是可以的。</p>

<p>前几天在登录 iPad 上的 Evernote 的时候，突然提示我登录的设备超过了两台，需要开通会员（之前开通过一年的会员，后来没有续费），总觉得为了这个再开通会员有点不值得，并且之前 Evernote 在 Mac 上使用就有很多诟病，所以打算换 OneNote 了。更新了一下 Mac 上 OneNote，发现竟然支持手写了，果断用用用。不过 OneNote 最开始的字体问题到现在还没有解决……</p>

<p>下周五就可以玩上 Pokemon Moon 了，激动不已，虽然破解党们早已二周目通关……</p>

<p>另外，发现番茄工作法挺好用的，现在也没有什么课了，每天就直接到图书馆里来，打开番茄钟，然后无脑干活就好了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 45 Review]]></title>
    <link href="http://forrestchang.github.io/14824080993859.html"/>
    <updated>2016-12-22T20:01:39+08:00</updated>
    <id>http://forrestchang.github.io/14824080993859.html</id>
    <content type="html"><![CDATA[
<p>已经第 45 周了啊，再过 10 周 2016 年就要过去了。今天大连下起了雪，似乎冬天就这么不知不觉得来了，记得上一次下大雪的时候去了一次海边，可惜 Photos 在一次事故中数据全部丢失了。作为一个南方人当初决定来北方的时候其实是对雪有一种很强烈的期待的，不过来了大连之后发现其实这里也不怎么下雪，偶尔下一次的雪也不是很大，这在一定程度上有点令人失望。</p>

<p>上周在读《挪威的森林》这本书，第一次读的时候大概是在初中的时候，当时没看懂里面写的是什么，纯属当做一本小黄书来读的。这次读的时候依旧有好多东西没明白。有一天听着 Thirteen Senses 的专辑猛地读到了 50%，感觉特别压抑，说不出来的压抑，所以就暂时放下了，顺便把翻拍的电影看了一遍，说实话，电影拍得不是很好，剧情的跳跃度有些大了，让没读过小说的人看得莫名其妙。</p>

<p>学习方面感觉上周特别颓废，什么事情都不相干，每天就窝在宿舍里，果然宿舍是一个让人堕落的地方，甚至连门都不想出去了，吃饭全部叫外卖。还好今天周一强迫自己来了图书馆，希望能做些东西吧。</p>

<p>这学期的课程基本结束了，免修了两门课，除了上机可能会去一下，其他时间都是空余的了，有大块的时间可以用来做自己想要做额事情了。</p>

<p>看了一眼窗外，雪似乎已经停了，耳机里放着坂本龙一的「A Flower Is Not A Flower」。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 44 Review]]></title>
    <link href="http://forrestchang.github.io/14824080414983.html"/>
    <updated>2016-12-22T20:00:41+08:00</updated>
    <id>http://forrestchang.github.io/14824080414983.html</id>
    <content type="html"><![CDATA[
<ul>
<li><strong>Coding</strong> - 本周主要在看《利用 Python 进行数据分析》，大概看了有一半的样子，下周应该能够结束掉。接下来的打算可能是先不看书，而是把<a href="https://www.quora.com/What-should-I-learn-in-data-science-in-100-hours">What should I learn in data science in 100 hours?</a>这个问题下面的回答内容实践一遍。</li>
<li><strong>Japanese</strong> - 日语已经落下好久了，大概还有1个月的时间考试，虽然只是报了一个三级试试水，但是不去考试总感觉白费报名费了，当初以为交了钱就会好好学，然而想多了。另外，日语现在并不是刚需的语言，之前决定学习是为了玩游戏，现在基本想玩的游戏都出了中文，《怪物猎人》玩了几个小时，发现不适合我这种手残。所以到底要不要继续学习日语还有待商榷……</li>
<li><strong>English</strong> - 英语自从到了大学以来就没有刻意地学过，除了准备托福的那段时间背了一些单词，然后其他都是直接用，导致了现在听说读写水平参差不齐，听力和阅读还算可以（至少能听懂和读懂技术相关的内容），口语基本就是没有说过，写作也没怎么练过，写一些基本的句子也要查语法（靠语感来写作结果就是一堆语法错……）。相比较日语来说，英语还算一个刚需的技能，尤其是写作和口语部分，还需要加强训练。接下来的一段时间内也会把英语学习提到日程上来，暂时的计划还没有想好，先加到 TODO 中。</li>
<li><strong>Reading</strong> - 发现这学期都没有读过几本书，上学期还能保持基本每周都读一本书，现在 Kindle 都吃灰了。下周先把《挪威的森林》这本书看完吧……</li>
<li><strong>Game</strong> - 等《精灵宝可梦 日月》发售，还有20天的样子，没有预定，直接买现货或者买下载版吧。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建 Python 科学计算环境]]></title>
    <link href="http://forrestchang.github.io/14824083276745.html"/>
    <updated>2016-12-22T20:05:27+08:00</updated>
    <id>http://forrestchang.github.io/14824083276745.html</id>
    <content type="html"><![CDATA[
<p>最近在看《Python for Data Analysis》（利用 Python 进行数据分析）这本书，贴一点笔记，这一篇是关于环境搭建的。另外吐槽一下，书中还是有不少错误的，语法错误就发现了好多处，大概读完了之后会整理出一份勘误表出来，可能是因为写书的时候是 14 年，两年过去了，pandas 库也有了一些变化。</p>

<h2 id="toc_0">安装虚拟环境</h2>

<p>不想把系统的 python 库搞得乱乱的（其实已经很乱了），所以还是建一个独立虚拟环境专门来做科学计算吧。具体的方法我在<a href="http://forrestchang.github.io/2016/07/17/virtualenv-notes/">virtualenv 相关笔记</a>这篇博客中已经详细写了，建议将启动虚拟环境的命令添加到终端的配置文件中去（使用<code>alias</code>），这样就避免每次一打开就输入一长串命令了。</p>

<p>因为科学计算社区的一些库还是基于 Python 2.x 版本的，所以这里我们使用的 Python 版本为 2.7。</p>

<p>然后使用以下命令一键安装所需要的库：</p>

<pre><code class="language-shell">sudo pip install numpy pandas matplotlib jupyter scikit-learn
</code></pre>

<p>安装不上的请检查是不是需要翻墙。</p>

<h2 id="toc_1">IPython</h2>

<p>熟悉 Python 的同学应该对这个解释器不陌生，自带的 Python 解释器实在是太弱了。它与传统的“edit-compile-run”（编辑-编译-运行）方式的区别在于，它鼓励使用“execute-explore”（执行-探索），所以特别适合用在计算和数据分析领域，可以方便得使用「试错法」和「迭代法」进行开发。这里主要介绍它基于 Web 的交互式笔记本功能（命令行中大同小异）。</p>

<h3 id="toc_2">开启 IPython Notebook</h3>

<p>使用以下命令来打开 IPython Notebook：</p>

<pre><code class="language-shell">(ENV2.7)$ jupyter notebook
</code></pre>

<p>这样 server 就启动了，浏览器会自动打开一个目录树。</p>

<p>Note：记住在启动了虚拟环境的状态下使用这条命令，要不然就会使用系统的 IPython 版本来运行。</p>

<p>然后我们新建一个 IPython Notebook 用作演示：</p>

<p><img src="media/14824083276745/14776647413275.jpg" alt="14776647413275"/></p>

<p><code>In [1]</code> 中的命令是为了能让我们直接在 IPython Notebook 中集成显示 <code>matplotlib</code> 画的图片，所以如果是用作科学计算的话，首先先执行以下这条命令再说。</p>

<h3 id="toc_3">内省</h3>

<p>在变量的前面或后面加上一个 <code>?</code> 就可以将有关该对象的一些通用信息显示出来。</p>

<p><img src="media/14824083276745/14776649884990.jpg" alt="14776649884990"/></p>

<p>基本上什么都能看。</p>

<h3 id="toc_4"><code>%run</code> 命令</h3>

<p>使用 <code>%run</code> 可以运行本地的 Python 脚本，并可以在 IPython 中访问脚本中定义的所有变量。</p>

<p>如果想要脚本能够访问 IPython 中的命名空间，可以使用 <code>%run -i</code> 命令。</p>

<h3 id="toc_5">测试代码的执行时间</h3>

<p>使用 <code>%time</code> 和 <code>%timeit</code> 可以用来测试代码的执行时间。</p>

<p><img src="media/14824083276745/14776653395450.jpg" alt="14776653395450"/></p>

<h2 id="toc_6">Example</h2>

<p>下面使用一个具体的例子来演示 IPython Notebook 的使用。</p>

<p>使用到的数据可以在<a href="https://www.ssa.gov/oact/babynames/limits.html">Beyond the Top 1000 Names</a>下载到，这是一份包含1880-2015年每年出生婴儿姓名出现次数的数据表。</p>

<p>由于该数据按年份被分割成了好多文件，所以第一步我们需要把所有数据组装到一个 DataFrame 中去。</p>

<p><img src="media/14824083276745/14776659007521.jpg" alt="14776659007521"/></p>

<p>不知道这些 Python 代码没关系，因为这里只是用来演示 IPython Notebook。</p>

<p>然后我们按照性别和年度统计总出生数：</p>

<p><img src="media/14824083276745/14776660937109.jpg" alt="14776660937109"/></p>

<p>然后绘制出表格：</p>

<p><img src="media/14824083276745/14776661445090.jpg" alt="14776661445090"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 42-43 Review]]></title>
    <link href="http://forrestchang.github.io/14824079755630.html"/>
    <updated>2016-12-22T19:59:35+08:00</updated>
    <id>http://forrestchang.github.io/14824079755630.html</id>
    <content type="html"><![CDATA[
<p>连续两周没写周总结了，41周的周总结因为涉及到一些私事所以还是删掉了（当然感兴趣的还是可以在我的 repo 里面找到之前的 commit）。</p>

<p>过去两周还是发生了很多事情的，一件一件来说吧。</p>

<p>10.15-10.17 去上海参加了 HACKxFDU，这也是第一次参加 Hackathon，最后抱了大腿队友水到了一个微软的万物互联奖，不过奖品就两套物联网套件，根本不够四个人分(╯°□°）╯。在上海大概玩了一个礼拜，去了趟迪士尼（人多，体验差，项目无聊）就回学校了。然后上一周基本上没做什么事情，一是要准备大创项目的中期检查答辩，二是要复习软件工程的考试。</p>

<p>最近做出比较重要的一个决定就是确定了以后将要从业的方向，以前基本上都是按照兴趣来学，什么都做过一些，但都不是很深入，也没有想好以后工作想要干嘛。最近不知道怎么突然对数据挖掘和机器学习产生兴趣了，正好之前做的一个大创项目也是和这个有关的（虽然项目内容都是在划水），所以还算对这方面有点经验。</p>

<p>但是要解决的问题还是有很多的，比如说如何找到工作的问题，搜索了一下，机器学习/数据挖掘的岗位都需要有研究生学历，作为一个辣鸡学校的本科生，能不能找到工作就是一个问题。跟一个朋友说了一下想法，他说我在玩火……当然，实际上这方面倒不是太担心，如果有普通研究生能力的话找到一个工作还是不难的。</p>

<p>另外一个就是需要系统得学习这一套东西了，包括微积分、线性代数、概率论、统计学、机器学习，大部分内容是数学，现在有点后悔大一大二的时候没有好好学数学了，高数那些课基本就是划水过去的，欠下来的债还要还的。</p>

<p>现在基本的计划就是：</p>

<ol>
<li>看《利用 Python 进行数据分析》，把 Python 的几个科学计算库用熟练；</li>
<li>复习一下数学的知识，看《程序员的数学》系列的三本书，有基础的话应该挺快就能看完；</li>
<li>看李航的《统计学习方法》；</li>
<li>看《集体智慧编程》；</li>
<li>看周志华的《机器学习》；</li>
</ol>

<p>上面就是初步的入门计划，应该看完了对数据挖掘/机器学习有一个基本的了解了，可以顺便去 Kaggle 上打打比赛，虽然不一定能够能拿到好名次，积累一些经验总是好的。另外 Ng 的课和台大的《机器学习基石》也可以看一下。</p>

<p>其他一些资源：</p>

<ul>
<li><a href="https://github.com/ZuzooVn/machine-learning-for-software-engineers">Top-down learning path: Machine Learning for Software Engineers</a></li>
<li><a href="https://cn.udacity.com/course/machine-learning-engineer-nanodegree--nd009">机器学习工程师（中/英）</a></li>
<li><a href="https://cn.udacity.com/course/data-analyst-nanodegree--nd002">数据分析师（中/英）</a></li>
</ul>

<p>这周和下周的计划就是把《利用 Python 进行数据分析》这本书看完。</p>

<p>ps：买了《文明6》，感觉时间还是挺紧的(╯▽╰)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 40 Review]]></title>
    <link href="http://forrestchang.github.io/14824078620114.html"/>
    <updated>2016-12-22T19:57:42+08:00</updated>
    <id>http://forrestchang.github.io/14824078620114.html</id>
    <content type="html"><![CDATA[
<p>这周恰逢国庆假期，休息了两天（感觉今天貌似也在休息），明天学校断电断网（大农村条件艰苦），所以应该要出去一天，暂时的行程还没有安排。</p>

<h2 id="toc_0">编程</h2>

<h3 id="toc_1">总结</h3>

<p>首先收到了 <a href="http://fdu.hackx.org/#/">HACKxFDU</a> 的通过邮件，所以 14 号会去上海打一波酱油，以目前的水平如果不抱大腿感觉完全没有拿奖的可能性。主要的目的应该不是去参赛，可能会去找找下学期实习的目标，顺便认识一些大牛(≧▽≦)/</p>

<p>上周说要看完《Flask Web Development》，但是实际上并没有看完，大概看了一半的样子，期间还看了一些 Flask 的源码，打算边看书边看源码，然后之后再重新造一遍轮子。</p>

<h3 id="toc_2">计划</h3>

<p>之前就一直觉得自己的 Python 水平好像一直止步不前（传说中的半吊子水平），要做什么东西都是先 Google 一下用什么库，有些标准库中的内容也很不熟悉。昨天被学长问道最近在学什么，我说在看 Flask，然后就被鄙视了，然后通过对话才意识到 Library Reference 还没有完整的刷过，Python 的基础还是比较薄弱的。现在是个人就会 Python，不过刷过 Library Reference 的人应该还是不多的。</p>

<p>所以接下去的计划应该是：</p>

<ol>
<li>继续看 Flask（被鄙视也要看啊，开了头不能半途而废……），把源码看懂然后自己山寨一个，尝试着写一些基于 Flask 的 Project；</li>
<li>刷 Python Library Reference，用 ipython notebook 来做笔记，先刷一遍，不会的东西先跳过；</li>
<li>刷一下算法，这个是为了下学期的面试准备的，CLRS 没有看完，但是感觉想要看完会花掉不少的时间，看不看到时候再说，先把 LeetCode 刷一遍，然后《编程之美》、《编程珠玑》、《剑指 offer》这几本书刷一遍。</li>
</ol>

<p>这学期估计做完上面的事情时间就用得差不多了，下学期开始的时候就要为参加 GSoC 做一些准备了。</p>

<p>下周要做的事情：</p>

<ol>
<li>继续刷《Flask Web Development》，争取看完</li>
<li>看完 Python Library Reference 2、3、4节</li>
</ol>

<h2 id="toc_3">日语</h2>

<h3 id="toc_4">总结</h3>

<p>这周貌似完全没有学习日语！所以上周列的计划也没有完成，尴尬！时间分配上面还是有一点问题了，每天有计划今天计算机的东西要看哪些，但是日语的东西貌似一点也没有计划，想到了就看一点，所以没有想到的时候就完全不看了-_-|||</p>

<h3 id="toc_5">计划</h3>

<p>现在有点后悔抱名 N3 的考试了，以来 N3 没什么卵用，而来貌似自己好像并没有太多时间学习日语，还不如好好学习一下然后直接考 N2 或者 N1，但是如果不去考试的话就浪费了 350 大洋！</p>

<p>五十音基本上是会了，所以还是直接看《大家的日语》这本书，一天学习一课的样子，学习到第 5 课。</p>

<h2 id="toc_6">游戏</h2>

<p>最近发售的大作有点多啊，首先是 PC 上的《文明6》，然后 11 月份还有《精灵宝可梦 太阳·月亮》，其实主要是想玩日月……</p>

<h3 id="toc_7">Pokemon ORAS</h3>

<p>这周好像 OR 也没有玩多久，主要就是战斗宅邸推塔，今天超级单打打到 45 层失误跪了，目前的队伍还不是很稳，还要重新组一个队伍。另一方面打了几把排位，语言的关系对有些技能不是很熟悉，所以吃了好几次亏，而且没玩过 xy 导致 gen6 的精灵基本不认识。</p>

<p>入了对战坑之后发现这游戏根本不是小孩子玩的，虽说是「子供向」的游戏，但是对战方面实在是太硬核了，要了解的东西太多，玩了 70h+ 几乎才了解一些皮毛。不过日月出来了之后应该会好些，不会总是看到技能就要查图鉴是干嘛的了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 39 Review]]></title>
    <link href="http://forrestchang.github.io/14824077552377.html"/>
    <updated>2016-12-22T19:55:55+08:00</updated>
    <id>http://forrestchang.github.io/14824077552377.html</id>
    <content type="html"><![CDATA[
<p>好久没有写周总结了，所以这几周都过得比较颓废(≧▽≦)/</p>

<h2 id="toc_0">编程</h2>

<p>总的来说，好像这一周并没有做出什么东西来。本来是在看《Web Scraping with Python》这本书的，可以看到后面发现错误挺多的，都有一些最基本的语法错误，所以索性就直接不看了。然后知乎专栏的爬虫也一直没有开始写。</p>

<p>从前几周就开始使用 VS Code 了，比想象中的好用很多，上一次使用还是刚出的时候，很多东西都不完善，现在 1.0 版本有了很大的改进，作为主力编辑器应该是没有什么问题了。Atom 的启动速度还是那么慢，什么时候改进一些什么时候再说吧。Emacs 已经好久没有用了，应该没有什么特殊情况不会去用了吧，写 Lisp 和 Haskell VS Code 或许也能够胜任。</p>

<p>最近最烦心的一件事情就是不知道以后要从事什么方向的程序员了。目前自己的技术栈并不是很丰富，杂七杂八的东西研究了很多，赚钱的技能没学多少……所以还是有必要挑一个搬砖的技能好好磨练一下了。目前初步的计划是 Python Web 开发，然后顺带把 C 语言再看看然后去读 Python 的源码，再看一些经典的书（UNIX 系列）。</p>

<h3 id="toc_1">下周的计划</h3>

<p>把《Flask Web Development: Developing Web Applications with Python》这本书看完，然后把书中的博客例子做出来。</p>

<p>顺便写代码累了的时候可以刷刷《程序员修炼之道》这本书，以前看过其中的一部分，还是比较有意思的。</p>

<h2 id="toc_2">日语</h2>

<p>12月份就要考试了，然而我还没怎么开始学习。大概在 YouTube 上看了几节五十音的视频，其实五十音之前也都学过，平假名基本上还是熟悉的，就是片假名记不住-_-|||</p>

<h3 id="toc_3">下周的计划</h3>

<p>熟练掌握五十音，包括平假名和片假名的书写、发音。先把 YouTube 上那一个系列的视频看完吧，然后直接拿单词卡片来背，Anki 中也有单词本可以用来复习。</p>

<h2 id="toc_4">游戏</h2>

<p>这周没怎么玩游戏，守望先锋已经一周多没有玩了。</p>

<p>平时的时候玩 「Pokemon Omega Ruby」比较多，也就是孵孵蛋，打打对战塔，刚入对战坑，好多东西还不懂，还需要学习一个。</p>

<p>开始入门狼人杀，这周的几次聚会玩狼人杀很嗨，在某宝上买了一套卡牌，准备研究研究。</p>

<h2 id="toc_5">阅读</h2>

<p>看了一点《胡适留学日记》，拖到现在还没有看完，Kindle 好像来学校之后就有点吃灰了。</p>

<h3 id="toc_6">下周的计划</h3>

<p>看完《胡适留学日记》。</p>

<h2 id="toc_7">电影</h2>

<p>这周看了三部韩国的电影，分别是《隧道》、《釜山行》、《恐怖直播》，发现韩国的电影好好看！韩国的电影感觉黑色幽默和讽刺多一些，日本的电影中二气息比较多一些，国产的电影嘛……</p>

<p>相比较最近比较火的《釜山行》，个人还是感觉《隧道》比较好看一些。亚洲地区的丧尸片估计《釜山行》应该是最佳了，但是和欧美的一些丧尸片比起来，还是有差距的，其中的一些套路也都是别人玩过了的。《隧道》这部电影让我感觉和《活埋》很像，但是一个生还了，一个 gg 了……</p>

<h2 id="toc_8">杂项</h2>

<p>这周好像聚会比较多(≧▽≦)，已经吃了好几顿饭+去了一次 KTV，生活过得比较颓废。</p>

<p>是时候应该沉迷学习了(╯﹏╰）</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016/08/08 阅读笔记]]></title>
    <link href="http://forrestchang.github.io/14706584948925.html"/>
    <updated>2016-08-08T20:14:54+08:00</updated>
    <id>http://forrestchang.github.io/14706584948925.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"><a href="https://www.quora.com/How-can-I-study-for-10+-hours-a-day-without-getting-depressed-and-how-can-I-make-myself-get-used-to-it">Quora: How can I study for 10+ hours a day without getting depressed and how can I make myself get used it?</a></h2>

<p><em>Such a stupid question.</em></p>

<ol>
<li>Don&#39;t study more than 7.5 hours a day. You can&#39;t learn when you are exhausted.</li>
<li>Take a day off per week. Do something you like on that day.</li>
<li>Make a plan.What knowledge is most critical in each of the subjects? First, concentrate only on that.</li>
<li>Study from low to high resolution.</li>
<li>Nap. A lot.</li>
<li>Study one topic for 2.5 hours. Then switch to another. Continue.</li>
<li>Read. Then put down the book. Then summarize what you have read. Don&#39;t look at what you were reading when you summarize.</li>
</ol>

<hr/>

<ol>
<li>Avoid time specific plans unless you&#39;re a monk or living in an extremely isolated environment.</li>
<li>Create a simple mechanism for notes and plans. You don&#39;t need any complex thing. The aim here is to work efficiently so these tools should be tools, not the whole story.</li>
<li>Create tasks as atomic as possible. Task should not be long. Best practice is that the task can be done after 1-2 hours of efficient work. If the task is big, you divide it into subtasks. In other words, avoid context switching as much as possible.</li>
<li>Get rid of all external distraction.</li>
<li>Use Pomodoro Technique.</li>
<li>If you have a long-run work and you can&#39;t complete it at the end of the day, take a note for tomorrow&#39;s yourself in order to remember the basic of teh task. And tomorrow, you start the day by glancing over the connected tasks.</li>
</ol>

<hr/>

<p>If studying makes you depressed, it&#39;s because your mind considers it a chore that you&#39;re forced to do. Doing any such chore for long periods of time is awful and depressing. On the other hand, doing somehting you love is fun, even when it&#39;s physically or mentally exhausting. So what you need to do is make the experience more valuable and enjoyable.</p>

<ol>
<li>Knowing WHY you&#39;re learning something.</li>
<li>Really understanding what you&#39;re learning.</li>
</ol>

<hr/>

<ol>
<li>Learn and practise proven efficient and effective study tools like SQ5R and Cornell Notes.

<ul>
<li>SQ5R reading/satudying strategy: [Survey, Question, Read, Record, Recite, Review, Reflect], </li>
</ul></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[virtualenv 相关笔记]]></title>
    <link href="http://forrestchang.github.io/14824097975366.html"/>
    <updated>2016-12-22T20:29:57+08:00</updated>
    <id>http://forrestchang.github.io/14824097975366.html</id>
    <content type="html"><![CDATA[
<p>记录一些有关 virtualenv 的使用笔记。</p>

<h2 id="toc_0">安装</h2>

<p>直接使用 pip 来进行安装：</p>

<pre><code>$ sudo pip install virtualenv
</code></pre>

<h2 id="toc_1">用途</h2>

<p>主要用来创建隔离的 Python 开发环境，比如说一个项目需要用到 2.7 的库，另一个项目需要用到 3.0 的库，我们就可以使用  virtualenv 来分别给这两个项目创建虚拟的 Python 环境，这样可以有效的避免冲突。</p>

<p>virtualenv 会创建一个拥有独立安装目录的 Python 环境，该隔离环境不会与其他 virtualenv 环境共享模块（可以选择是否访问全局安装目录）。</p>

<h2 id="toc_2">使用</h2>

<h3 id="toc_3">创建虚拟环境</h3>

<p>最基本的使用：</p>

<pre><code>$ virtualenv ENV
</code></pre>

<p>其中 <code>ENV</code> 是用来存放虚拟环境的目录。</p>

<pre><code>$tree -L 1 ENV
ENV
├── bin
├── include
├── lib
└── pip-selfcheck.json
</code></pre>

<p>其中 <code>lib</code> 和 <code>include</code> 目录是用来存放新的虚拟 Python 环境的依赖库，Package 被安装到 <code>lib/pythonX.X/site-packages/</code> 中，<code>bin</code> 目录中是新的 Python 解释器。<code>pip</code> 和 <code>setuptools</code> 默认被安装的。</p>

<h3 id="toc_4">active script</h3>

<p>进入虚拟环境：</p>

<pre><code>$ source ENV/bin/active
</code></pre>

<p>（如果 <code>source</code> 命令不存在可以使用 <code>.</code> 命令。）</p>

<p>退出虚拟环境：</p>

<pre><code>$ deactivate
</code></pre>

<h3 id="toc_5">Removing an Environment</h3>

<pre><code>(ENV)$ deactivate
$ rm -r /path/to/ENV
</code></pre>

<h3 id="toc_6"><code>--system-site-packages</code> 选项</h3>

<p>使用 <code>virtualenv --system-site-packages ENV</code> 将会继承全局 packages。并不是很常用的功能。</p>

<h3 id="toc_7">指定 Python 版本</h3>

<p>使用 <code>-p PYTHON_EXE</code> 选项在创建虚拟环境的时候制定 Python 版本。</p>

<p>Python 2.7:</p>

<pre><code>$ virtualenv -p /usr/bin/python2.7 ENV2.7
</code></pre>

<p>Python 3.5:</p>

<pre><code>$ virtualenv -p /usr/local/bin/python3.5 ENV3.5
</code></pre>

<h3 id="toc_8">生成可打包环境</h3>

<p>某些情况下，我们可能需要在别的地方使用这个已经配置好的虚拟环境，可以使用 <code>virtualenv --relocatable</code> 将 ENV 修改为可迁移的。</p>

<pre><code>(ENV)$ virutalenv --relocatable ./
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Python Tutorial Reading Notes]]></title>
    <link href="http://forrestchang.github.io/14824095038232.html"/>
    <updated>2016-12-22T20:25:03+08:00</updated>
    <id>http://forrestchang.github.io/14824095038232.html</id>
    <content type="html"><![CDATA[
<p><em>The Python Tutorial</em> is a good stuff to learn Python. I have already read it sketchily before, but didn&#39;t foucs on some detail things. This time I read it again and write some notes.</p>

<h2 id="toc_0">Data Structures</h2>

<h3 id="toc_1">More on Lists</h3>

<ul>
<li><code>list.append(x)</code>: Equivalent to <code>a[len(a):] = [x]</code></li>
<li><code>list.extend(L)</code>: Extend the list by appending all the items in the given list. Equivalent to <code>a[len(a):] = L</code></li>
<li><code>list.insert(i, x)</code>: The first argument is the index of the element before which to insert. <code>a.insert(len(a), x)</code> == <code>a.append(x)</code>.</li>
<li><code>list.remove(x)</code>: Remove the first item form the list whose value is x.</li>
<li><code>list.pop([i])</code>: Remove the item at the given position in the list, and return it. If no index is specified, <code>a.pop()</code> removes and returns the last item in the list.（parameters with square brackets are optional）</li>
<li><code>list.clear()</code>: Remove all item from the list. Equivalent to <code>del a[:]</code></li>
<li><code>list.index(x)</code>: Return the index in the list of the first item whose value is x.</li>
<li><code>list.count(x)</code>: Return the number of times x appears in the list.</li>
<li><code>list.sort(key=None, reverse=False)</code>: Sort the items of the list in place.</li>
<li><code>list.reverse()</code>: Reverse the elements of the list in place.</li>
<li><code>list.copy()</code>: Return a shallow copy of the list. Equivalent to <code>a[:]</code>.</li>
</ul>

<h4 id="toc_2">Using Lists as Stacks</h4>

<p>Use <code>append</code> and <code>pop</code>.</p>

<h4 id="toc_3">Using Lists as Queues</h4>

<p>Lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from beginning of a list is slow.</p>

<p>Better to use <code>collections.deque</code>.</p>

<h4 id="toc_4">List Comprehensions</h4>

<ul>
<li><code>x = [item for item in series]</code></li>
<li><code>x = [do_something(item) for item in series if expression]</code></li>
</ul>

<h4 id="toc_5">Nested List Comprehensions</h4>

<p>The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension.</p>

<p>Example: <code>[[row[i] for row in matrix] for i in range(4)]</code>.</p>

<h4 id="toc_6">The <code>del</code> statement</h4>

<p>Remove an item from a list given its index. (Do not return a value) It can also remove slices from a list.</p>

<p><code>del</code> can also be used to delete entire variables: <code>del a</code>.</p>

<h3 id="toc_7">Tuples and Sequences</h3>

<p>Tuples are <code>immutable</code>, and usually contain a heterogeneous sequence of elements that are accessed via unpacking or indexing. List are <code>mutable</code>, and their element are usually homogeneous and are accessed by iterating over the list.</p>

<ul>
<li>Empty tuples are constructed by and empty pair of parentheses: <code>empty = ()</code></li>
<li>A tuple with one item is constructed by following a value with a comma:     <code>sigleton = &#39;hello&#39;,</code></li>
</ul>

<p>The statement <code>t = 1, 2, &#39;hello&#39;</code> is an example of <code>tuple packing</code>: the values are packed together in a tuple. The reverse operation is also possible: <code>x, y, z = t</code>.</p>

<h3 id="toc_8">Sets</h3>

<p><code>{}</code> or <code>set()</code> function can be used to create sets. Note: to create an empty set you have to use <code>set()</code>, not <code>{}</code>; the latter creates an empty dictionary.</p>

<p>Example: </p>

<pre><code class="language-python">a = set(&#39;abracadabra&#39;)
b = set(&#39;alacazam&#39;)
</code></pre>

<ul>
<li><code>a - b</code>: letters in a but not in b</li>
<li><code>a | b</code>: letters in either a or b</li>
<li><code>a &amp; b</code>: letters in both a and b</li>
<li><code>a ^ b</code>: letters in a or b but not both</li>
</ul>

<p>Similaryly to list comprehensions, set comprehensions are also supported.</p>

<h3 id="toc_9">Dictionaries</h3>

<p>Dictionaries are indexed by keys, which can be any immutable type; strings and numbers can slways be keys. Tuples can be used as keys if they contain only one kind of item. You can&#39;t use use lists as keys, since lists can be modified in place using index assignments, slice assignments, or method like append() and extend().</p>

<p>It is best to think of a dictionary as an unordered set of <code>key: value</code> pairs.</p>

<ul>
<li><code>del</code> can delete a <code>key: value</code></li>
<li><code>list(d.keys())</code> on a dictionary returns a list of all the keys used in the dictionary, in arbitrary order (if you want it sorted, use <code>sortted(d.keys())</code> instead).</li>
<li>To check whether a single key is in the dictionary, use the <code>in</code> keyword. (<code>in</code> or <code>not in</code>)</li>
<li>Dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: <code>{x: x**2 for x in range(10)}</code></li>
<li>When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments: <code>dic(sape=1, guido=2, jack=3)</code> =&gt; <code>{&#39;sape&#39;: 1, &#39;jack&#39;: 3, &#39;guido&#39;: 2}</code></li>
</ul>

<h3 id="toc_10">Looping Techniques</h3>

<p>When looping through dictionaries, the key and corresponding value can be retrieved at the same time using the items() method.</p>

<pre><code class="language-python">knights = {&#39;gallahad&#39;: &#39;the pure&#39;, &#39;robin&#39;: &#39;the brave&#39;}
for k, v in knights.items():
    print(k, v)
</code></pre>

<p>When looping through a sequence, the position index and correspoding value can be retrieved at the same time using the <code>enumerate()</code> function.</p>

<pre><code class="language-python">for i, v in enumerate([&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;]):
    print(i, v)
</code></pre>

<p>To loop over two or more sequences at the same time, the entries can be paired with the <code>zip()</code> function.</p>

<pre><code class="language-python">numbers = [1, 2, 3]
names = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]
for number, name in zip(numbers, names):
    print(&#39;Number: {0}, Name: {1}&#39;.format(number, name))
</code></pre>

<p>To loop over a sequence in sorted order, use the <code>sorted()</code> function which return a new sorted list while leaving the source unaltered. <code>for item in soted(list)</code></p>

<p>It is sometimes tempting to change a list while you are looping over it; however, it is often simple and safer to create a new list instead.</p>

<h3 id="toc_11">More on Conditions</h3>

<ul>
<li><code>in</code> and <code>not in</code>: check whether a value occurs (or not) in a sequence.</li>
<li><code>is</code> and <code>is not</code>: compare whether two objects are really the same object; this only matters for mutable objcts like lists.</li>
<li>Comparisons can be chained. <code>a &lt; b == c</code></li>
<li><code>and</code> and <code>or</code> are <code>short-circuit</code> operators</li>
</ul>

<h3 id="toc_12">Comparing Sequences and Other Types</h3>

<p>The comparison uses lexicographical ordering.</p>

<h2 id="toc_13">Modules</h2>

<p>A module is a file containing Python definitions and statements. The file name is the module name with the suffix <code>.py</code> appended. Within a module, the module&#39;s name (as a string) is available as the value of the global variable <code>__name__</code>.</p>

<h3 id="toc_14">More on Modules</h3>

<p>Note that in general the practice of importing <code>*</code> from a module is frowned upon, since it often causes poorly readable code. (It ok to use in interactive sessions.)</p>

<p>It&#39;s one module you want to test interactively, use <code>importlib.reload()</code>.</p>

<pre><code class="language-python">import importlib
importlib.reload(modulename)
</code></pre>

<h4 id="toc_15">Executing modules as scripts</h4>

<pre><code class="language-python">if __name__ == &quot;__main__&quot;:
    code
</code></pre>

<p>This is often used either to provide a convenient user interface to a module, or for testing purposes (running the module as a script executes a test suite).</p>

<h4 id="toc_16">The Module Search Path</h4>

<p>When a module named <em>spam</em> is imported, the interpreter first searches for a built-in module with that name. If not found, it then searches for a file named <code>spam.py</code> in a list of directories given by the variable <code>sys.path</code>, it is initialized from these locations:</p>

<ul>
<li>The directory containing the input script (or the current directory when no file is specified).</li>
<li><code>PYTHONPATH</code> (a list of directory names, with the same syntax as the shell variable <em>PATH</em>).</li>
<li>The installation-dependent default.</li>
</ul>

<p>After initialization, Python programs can modify <code>sys.path</code>. The directory containing the script being run is placed at the beginning of the search path, ahead of the standard library path. This means that scripts in that directory will be loaded instead of modules of the same name in the library directory.</p>

<h4 id="toc_17">&quot;Compiled&quot; Python files</h4>

<p>Python caches the compiled version of each module in the <code>__pycache__</code> directory. It generally contains the Python version number. This naming convention allows compiled modules from dirrerent release and different version of Python to coexist. (Example: <code>__pycache__/fib.python-27.pyc</code>)</p>

<p>Python check the modification date of the source against the compiled version to see if it&#39;s out of date and needs to be recompiled.</p>

<h3 id="toc_18">Standard Modules</h3>

<pre><code class="language-python">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.ps1
&#39;&gt;&gt;&gt; &#39;
&gt;&gt;&gt; sys.ps2
&#39;... &#39;
&gt;&gt;&gt; sys.ps1 = &#39;C&gt; &#39;
C&gt; print(&#39;Yuck!&#39;)
Yuck!
</code></pre>

<p>The variable <code>sys.path</code> is a list of strings that determines the interpreter&#39;s search path for modules. You can modify it using standard list operations.</p>

<h3 id="toc_19">The <code>dir()</code> Function</h3>

<p>The built-in function <code>dir()</code> is used to find out which names a module defines.</p>

<p>Without arguments, <code>dir()</code> lists the names you have defined currently.</p>

<p>It list all types of names: variable, modules, functions, etc.</p>

<h2 id="toc_20">Input and Output</h2>

<h3 id="toc_21">Methods of File Objects</h3>

<p>It is good practice to use the <code>with</code> keyword when dealing with file objects. This has the advantage that the file is properly closed after its suite finishes, even if an exceptiohn is raissed on the way. It is also much shorter thatn writing equivalent <code>try-finally</code> blocks:</p>

<pre><code class="language-python">with open(&#39;workfile&#39;, &#39;r&#39;) as f:
    read_data = f.read()
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016/07/02 阅读笔记]]></title>
    <link href="http://forrestchang.github.io/14674443542637.html"/>
    <updated>2016-07-02T15:25:54+08:00</updated>
    <id>http://forrestchang.github.io/14674443542637.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"><a href="https://m.signalvnoise.com/how-i-became-and-stayed-a-successful-programmer-48f209362f68#.davwu8c5x">How I became (and stayed) a successful programmer</a></h2>

<p>How do I take a new skill like programming, grow it, shape it, and tune it over time so I can achieve longevity in the industry?</p>

<h3 id="toc_1">1. I surround myself with programmers who are way better than me</h3>

<p>The best way to improve (at anything) is to learn from people better than you.</p>

<p>I remind myself to talk less and to listen more.</p>

<h3 id="toc_2">2. I occasionally leave my comfort zone</h3>

<p>Leaving comfort zone helps me think differently by challenging a bunch of established ideas I already have.</p>

<p>Maybe you don&#39;t want to do this constantly because it can be hard to get into a rhythm with your normal area of work. But in moderation it can really open your mind to new ways of thinking.</p>

<p>Find a programming task that takes you out of your comfort zone and make it your next project. Then watch it pay off in spades.</p>

<h3 id="toc_3">3. I value being independent</h3>

<p>What&#39;t most inportant is how you choose to find the answers to your questions.</p>

<p>This means I&#39;ll try to do most things myself first, and only when I really get stuck, I&#39;ll ask for help.</p>

<p>Benefits:</p>

<ul>
<li>You learn how to be resourceful.</li>
<li>You earn respect by being courteous of other people&#39;s time and work.</li>
<li>You start developing your creativity.</li>
</ul>

<h2 id="toc_4"><a href="https://medium.freecodecamp.com/please-dont-quit-every-expert-was-once-a-beginner-6d8f8933a338#.d0nbkocf7">Please don&#39;t quit -- every expert was once a beginner</a></h2>

<h3 id="toc_5">Great developments never come from within your comfort zone</h3>

<p>It&#39;s always hard to push yourself to the next level, because it requires greater effort than the usual. It requires more energy, which may tire you physically and mentally.But don&#39;t think about that. Think about the result. The achievement.</p>

<p>Every time you take a step toward expertise, no matter how small, it is still a step.</p>

<h3 id="toc_6">Learn in diffuse mode</h3>

<p>Since it may be hard to get a concept the first time you read about it, you can do something that will make it better for you and help you get it quickly.</p>

<p>Read the full text with total focus (first time, even if you don&#39;t understand), okay? Now, read it again. After the second time, google the concept and try to read about it in different articles. That will help you see it from different angles, which will help you better understand it.</p>

<p>Next time is to read the text a third time. Your understanding of the concept is much better now than it was the first time you read it, even though in all likelihood you&#39;re still early on in your quest to truly understand that concept.</p>

<p>This medhod is called <strong>Diffuse mode</strong>. You can apply this type of learning toward applies to videos and tutorials, as well.</p>

<p><strong>Every expert was once a beginner.</strong></p>

<blockquote>
<p>&quot;You never fail until you stop trying.&quot; - <strong>Albert Einstein</strong></p>
</blockquote>

<p>You should know that reaching a high level takes time.</p>

<blockquote>
<p>&quot;I&#39;m convinced that about half of what separates the successful Entrepreneurs from the non-successful ones is pure perseverance.&quot; - <strong>Steve Jobs</strong></p>
</blockquote>

<p>Some tips:</p>

<ul>
<li>Don&#39;t work alone.</li>
<li>Don&#39;t wait for inspiration. <strong>Discipline is reliable.</strong></li>
<li>Real work usually isn&#39;t fun.</li>
<li>Practice, practice, and practice.</li>
<li>Tutorials fish on your behalf, so you don&#39;t need to learn how to fish yourself. <strong>You need to read books.</strong></li>
<li>Always try to understand a new concept using different resources.</li>
<li>Don&#39;t just read. Build. Try, try, and keep trying.</li>
<li>Frustration, boredom, tiredness, exhaustion -- these are all normal. </li>
<li>Ask.</li>
</ul>

<blockquote>
<p>&quot;Long-term consistency trumps short-term intensity.&quot; - <strong>Bruce Lee</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 21 阅读笔记]]></title>
    <link href="http://forrestchang.github.io/14636395892916.html"/>
    <updated>2016-05-19T14:33:09+08:00</updated>
    <id>http://forrestchang.github.io/14636395892916.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎样花两年时间去面试一个人</a></h2>

<blockquote>
<p>The great software developers, indeed, the best people in every field, are quite simply never on the market.j</p>

<p>The average great software developer will apply for, total,maybe, four jobs in their entire career.</p>

<p>—— <a href="http://www.joelonsoftware.com/articles/FindingGreatDevelopers.html">Joel Spolsky</a></p>

<ol>
<li>最好的人也许不投简历，就决定去哪里了。所以要在他们做决定之前找到他们。</li>
<li>比较差的会投很多次简历，找不到工作的时间约多，投的简历越多，给整个 pool 带来很多噪音，top 10% 的简历也许根本不算全部人的 top 10%。</li>
</ol>

<p>—— 邹欣</p>
</blockquote>

<p>Joel Spolsky 写了一本书，专门讲了公司招聘的心得和体会，<a href="http://www.amazon.com/Smart-Gets-Things-Done-Technical/dp/1590598385/">《Smart and Gets Things Done》</a>。</p>

<p>现在绝大多数应届生简历而言，也许最具信息量的部分不是「精通 xxx，熟悉 yyy，掌握 zzz」，不是「在 uuu 实习过」，也不是这个项目那个作业，反倒是越来越被认为不重要的一项：毕业学校。原因是简历上的其他条目的信息量太小了。</p>

<p>很多时候，是否好好看完一本好书，对一个人的提升往往能达到质的区别。就算不好好看完一本书，马马虎虎看完，只要书是真的函数，也肯定会有很大提高。</p>

<p>好书和坏书的差别，从本质上，就是学习效率和大方向的差别。读烂书浪费时间，但读好书却节省时间。</p>

<p>「书单计划」的优点：</p>

<ol>
<li>清晰、明确。完全可度量。</li>
<li>防伪：读没读过，随便一问便知。而正因为应聘者也知道这事不像实习经验可以忽悠，所以也不敢乱往简历上捅词。</li>
<li>不在乎是否「泄题」：书单是完全公开的，无所谓，本来就是要你去读的。</li>
<li>管你用心不用心读，只要读了，读完了，就有区别。（笔者注：根据经验，没有用心读完可能真的没有什么卵用）</li>
<li>不存在「怎么做」的障碍：所有人都知道怎么读书——一页一页读。</li>
<li>不需要招聘者投入精力：书单在此，就这么简单。</li>
<li>评估的负担很大程度上转移到了应聘者身上：是不是认真看完了，有没有心得体会。</li>
</ol>

<p>「书单计划」的背后是另一个悲剧的现实，如果不是因为这个现实，这个计划也完全没有必要，那就是，中国 IT 大学教育当中要求学的书，和企业真正需要你读的书相比，不是完全不够用，就是写得不够好，或者更悲剧的就是根本用不上，所以在这个大背景下出来的牛人都是自己淘书自己学的。</p>

<blockquote>
<p>第一份工作的月薪 = 大学四年买过的技术书籍价格的总和</p>

<p>—— 熊力</p>
</blockquote>

<p><strong>GitHub</strong></p>

<p>有经验的面试者只要稍稍扫两眼一个人的 GitHub 历史，跳出几个 check-in 历史看一看，便完全能够迅速判断这个人是否满足他的要求。不再需要费劲心机地去想题目，去观察，去揣测，去花费大量的时间的同时还只能采样到几个极为有限的点。</p>

<p>书单 + GitHub，就相当于一个两年左右的面试。</p>

<p>没有哪个行业像 IT 行业这样特殊：没有什么东西不能够（应该）在互联网上学到的。</p>

<hr/>

<p>一些书单</p>

<ol>
<li>《编码的奥秘》</li>
<li>《深入理解计算机系统》</li>
<li>《Windows 核心编程》</li>
<li>《程序员的自我修养》</li>
<li>《代码大全》</li>
<li>《程序员修炼之道》</li>
<li>《编程珠玑》</li>
<li>《编程之美》</li>
<li>《The C Programming Language》</li>
<li>《The C++ Programming Language》</li>
<li>《Programming: Principles and Practice Using C++》</li>
<li>《Accelerated C++》</li>
<li>《计算机程序的构造和解释》</li>
<li>《Clean Code》</li>
<li>《Implementation Patterns》</li>
<li>《Design Patterns》</li>
<li>《Agile Software Development, Principles, Patterns, and Practices》</li>
<li>《Refactoring》</li>
<li>《C++ 编程思想》</li>
<li>《Effective C++》</li>
<li>《深度探索 C++ 对象模型》</li>
<li>《C++ 语言的设计和演化》</li>
<li>《C 专家编程》</li>
<li>《C 陷阱与缺陷》</li>
<li>《C 语言接口与实现》</li>
<li>《Lua 程序设计》</li>
<li>《Linkers and Loaders》</li>
<li>《COM 本质论》</li>
<li>《深入理解 Windows 操作系统》</li>
<li>《Unix 编程艺术》</li>
<li>《代码优化：有效使用内存》</li>
<li>《深入理解 Linux 内核》</li>
<li>《TCP/IP 详解》</li>
<li>《软件随想录》</li>
<li>《黑客与画家》</li>
<li>《编程人生》</li>
<li>《人月神话》</li>
<li>《算法导论》</li>
<li>《快速软件开发——有效控制与完成进度计划》</li>
<li>《IT 项目管理那些事》</li>
<li>《最后期限》</li>
<li>《走出软件作坊》</li>
<li>《你的灯亮着吗》</li>
<li>《Algorithms》(by Sanjoy Dasgupta, Christos Papadimitriou and Umesh Vazirani)</li>
<li>《Data Structures and Algorithms》</li>
<li>《The Design of the UNIX Operating System》</li>
<li>《Compilers》(龙书)</li>
<li>《Computer Architecture: A Quantitative Approach》</li>
<li>《Flow》</li>
<li>《Outliers》（Why hard work and luck are both important）</li>
</ol>

<h2 id="toc_1"><a href="http://mindhacks.cn/2008/09/17/learning-habits-part3/">一直以来伴随我的一些学习习惯（三）：阅读方法</a></h2>

<ol>
<li>乘着对一件事有热情的时候，一股脑把万事那个最难的阶段熬过去。</li>
<li>根据主题来查阅资料，而不是根据资料来查阅主题。按照主题来阅读，你会发现读的时候不再是老老实实地一本书看完再看另一本，而是非常频繁地从一本书跳到另一本书，从一处资料跳到另一处资料，从而来获得多个不同的人对同一个主题是如何讲解的。因为即便是经典的书，你也不能指望它对其中每一个主题的介绍都是尽善尽美的，有些书对某个主题（知识点）的介绍比较到位，有些书则对另一些知识点介绍得比较到位。而有时候一篇紧凑的 paper 比一本书上讲得还要好。我硬盘里面的书按照主题分类，每个主题下面都有一堆书，当我需要学习某个主题的知识时，我会把里面涉及这个主题的书都翻开来，索引到相关章节，然后挑讲得好的看。</li>
<li>好资料，坏资料。好资料的特点：从问题出发；重点介绍方法背后的理念，注重直观解释，而不是方法的技术细节；按照方法被发明的时间流程来介绍（先是遇到什么问题，然后怎样分析，推理，最后发现目前所使用的方法）。坏资料的特点是好资料的反面：上来就讲方法细节，仿佛某方法是从天上掉下来的。根本不讲为什么要用这个方法，人们最初是因为面对什么问题才想到这个方法的，其间又是怎样才想出这个方法的，方法背后的直观思想又是什么。</li>
<li>学习一个东西之前，首先在大脑中积累充分的「疑惑感」。即弄清面临的问题到底是什么，在浏览方法本身之前，最好先使劲问问自己能想到什么方法。一个公认的事实是，你对问题的疑惑越大，在之前做的自己的思考越多，当看到借到之后的印象就越深刻。</li>
<li>有选择地阅读。这里的选择体现在两个地方，一是选择一本书中感兴趣的章节优先阅读，二是对一本书中技术性较弱或信息密度较低的部分快速地略读。一般来说，除了技术性非常强的书之外，大多数书的信息密度很低，有很多废话。一般来说在阅读的时候应该这样来切分内容：1. 问题是什么？2. 方案是什么？3. 例子是什么？如果是需要解释一个现象的，那么1. 现象是什么？2. 解释是什么？3. 之城这个解释的理由是什么？ 4. 例子是什么。</li>
<li>为什么看不懂？1. 你看得不够使劲。对于这类情况，仔仔细细地再多读两遍，多试着去理解两遍，往往会恍然大悟。2. 其中涉及到了你不懂得概念，这是技术性的不理解，这种情况就需要 Cross Reference。如果一句话中用到了你不懂得概念，那就去查。奇怪的是很多人看不懂也不分析一下为什么不懂，就直接放弃了。正如解决问题一样，问题卡住解决不了了，第一时间要做的就是分析为什么解决不了，而不是直接求救。3. 作者讲述的顺序不对，你接着往下看，也许看到后面就明白前面的了。</li>
<li>如何搜寻到好书。1. 同作者的著作。2. Amazon 相关推荐和主题相关的书列。3. 一本好的著作（或一份好的资料——不管是书还是网页）在参考资料里面重点提到的其他著作。4. 有时对于一个主题，可以搜索到好心人总结的参考资源导引，那是最好不过的。</li>
</ol>

<h2 id="toc_2"><a href="http://matt.might.net/articles/what-cs-majors-should-know/">What every computer science major should know</a></h2>

<ul>
<li>What should every student know to get a good job?</li>
<li>Waht should every student know to maintain lifelong employment?</li>
<li>What should every student know to enter graduate school?</li>
<li>What should every student know to benefit society?</li>
</ul>

<p><strong>Portfolio versus resume</strong></p>

<p>Every computer science major should build a portfolio.</p>

<p>A portfolio could be as simple as a personal blog, with a post for each project or accomplishment. A better portfolio would include per-project pages, and publicly browsable code (hosted perhaps on github or Google code).</p>

<p>Contributions to open source shold be linked and documented.</p>

<p>A code portflolio allows employers to direcctly judge ablility. GPAs and resumes do not.</p>

<p><strong>Technical communication</strong></p>

<p>I would recommend that students master a presentation tool like PowerPoint or (my favorite) Keynote.</p>

<p>For producing beautiful mathematival documentation, \(LaTex\) has not equal. All written assignments in techical courses should be submitted in LaTex.</p>

<p><strong>An engineering core</strong></p>

<p><strong>The Unix philosophy</strong></p>

<p>The Unix philosophy is one that emphassizes linguistic abstraction and composition in order to effect computation.</p>

<p><strong>Systems administration</strong></p>

<p><strong>Programming Language</strong></p>

<p><strong>Discrete mathematics</strong></p>

<p><strong>Data structures and algorithms</strong></p>

<p><strong>Theory</strong></p>

<p><strong>Architecture</strong></p>

<p><strong>Operating System</strong></p>

<p><strong>Networking</strong></p>

<p><strong>Security</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift学习笔记：控制流]]></title>
    <link href="http://forrestchang.github.io/14635617646524.html"/>
    <updated>2016-05-18T16:56:04+08:00</updated>
    <id>http://forrestchang.github.io/14635617646524.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Repeat-While</h2>

<p><code>repeat-while</code> 在 <code>while</code> 判断循环条件之前，先执行一次循环的代码块，和其他语言中的 <code>do-while</code> 是类似的。</p>

<pre><code class="language-swift">repeat {
    statements
} while condition
</code></pre>

<h2 id="toc_1">Switch</h2>

<p><code>switch</code> 语句会尝试把某个值与若干个模式（pattern）进行匹配。根据第一个匹配成功的模式，<code>switch</code>语句会执行对应的代码。当有可能的情况较多时，通常用 <code>switch</code> 语句替换 <code>if</code> 语句。</p>

<p><code>switch</code> 语句必须是完备的，每一个可能的值都必须至少有一个 case 分支与之对应。在某些不可能涵盖所有值得情况下，你可以使用默认（<code>default</code>）分支满足该要求，这个默认分支必须在 <code>switch</code> 语句的最后面。</p>

<h3 id="toc_2">不存在隐式的贯穿（No Implicit Fallthrouth）</h3>

<p>和其他语言的 Switch 不同，在 Swift 中，当匹配的 case 分支中的代码执行完毕后，程序会终止 <code>switch</code> 语句，而不会继续执行下一个 case 分支。所以，不需要再 case 分支中显式地使用 <code>break</code> 语句。</p>

<p>如果想要贯穿到特定的 case 分支中，请使用 <code>fallthrough</code> 语句。</p>

<h3 id="toc_3">区间匹配</h3>

<p>case 分支的模式也可以是一个值得区间。</p>

<h3 id="toc_4">元组</h3>

<p>可以只用元组在同一个 <code>switch</code> 语句中测试多个值，元组中的元素可以是值，也可以是区间，使用下划线 <code>_</code> 来匹配所有可能的值。</p>

<h3 id="toc_5">值绑定</h3>

<p>case 分支的模式允许将匹配的值绑定到一个临时的常量或变量，这些常量或变量在该 case 分支里就可以被引用了。</p>

<p>case 分支的模式可以使用 <code>where</code> 语句来判断额外的条件。</p>

<h2 id="toc_6">控制转移语句</h2>

<h3 id="toc_7">continue</h3>

<p><code>continue</code> 语句告诉一个循环体立刻停止本次循环迭代，重现开始下次循环迭代。</p>

<h3 id="toc_8">break</h3>

<p><code>break</code> 语句会立即结束整个控制流的执行。</p>

<h2 id="toc_9">带标签的语句</h2>

<p>在 Swift 中，你可以在循环体和 <code>switch</code> 代码块中嵌套循环体和 <code>switch</code> 代码块来创造复杂的控制流结构。然而，循环体和 <code>switch</code> 代码块亮着都可以使用 <code>break</code> 语句来提前结束整个方法。因此，显式地指明 <code>break</code> 语句想要终止是哪个循环体或者 <code>switch</code> 代码块，会很有用。</p>

<p>为了实现这个目的，可以使用标签来标记一个循环体或者 <code>switch</code> 代码块，当使用 <code>break</code> 或者 <code>continue</code> 时，带上这个标签，可以控制该标签代表对象的中断或者执行。</p>

<p>语法：</p>

<pre><code class="language-swift label"></code></pre>

<h2 id="toc_10">提前退出</h2>

<p>像 <code>if</code> 语句一样， <code>guard</code> 的执行取决于一个表达式的布尔值。我们可以使用 <code>guard</code> 语句来要求条件必须为真时，以执行 <code>guard</code> 语句后的代码。不同于 <code>if</code> 语句，一个 <code>guard</code> 语句总是有一个 <code>else</code> 分句，如果条件不为真则执行 <code>else</code> 分句中的代码。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：字符串和字符]]></title>
    <link href="http://forrestchang.github.io/14634546001476.html"/>
    <updated>2016-05-17T11:10:00+08:00</updated>
    <id>http://forrestchang.github.io/14634546001476.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">字符串是值类型</h2>

<p>使用字符串会进行值拷贝。</p>

<p>在实际的编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着将字符串作为值类型的同时可以获得极高的性能。</p>

<h2 id="toc_1">Working with Characters</h2>

<p>可以使用 <code>for-in</code> 循环来遍历字符串中的 <code>characters</code> 属性来获取每一个字符的值。</p>

<p>字符串可以通过传递一个值类型为 <code>Character</code> 的数组作为自变量来初始化。</p>

<h2 id="toc_2">连接字符串和字符</h2>

<p>字符串可以通过加法运算符相加在一起创建一个新的字符串。</p>

<p><code>append()</code> 方法可以将一个字符附加到一个字符串变量的尾部。</p>

<h2 id="toc_3">Unicode</h2>

<h3 id="toc_4">Unicode Scalars（Unicode 标量）</h3>

<p>Swift 的 <code>String</code> 类型是基于 Unicode 标量建立的。Unicode 标量是对应字符或者修饰符的唯一的 21 位数字。</p>

<p>Unicode 码位（code poing）的范围是 <code>U+0000</code> 到 <code>U+1F425</code> 或者 <code>U+E000</code> 到 <code>U+10FFFF</code>。Unicode 标量不包括 Unicode 代理项（surrogate pair）码位，其码位范围是 <code>U+D800</code> 到 <code>U+DFFF</code>。</p>

<p>注意，并不是所有的 21 位 Unicode 标量都表示一个字符，因为有一些标量是留作未来分配的。</p>

<h3 id="toc_5">字符串字面量的特殊字符（Special Character in String Literals）</h3>

<p><img src="media/14634546001476/14634553799193.jpg" alt=""/></p>

<h3 id="toc_6">可扩展的字形群集（Extended Grapheme Clusters）</h3>

<p>每一个 Swift 的 Character 类型代表一个可扩展的字形群。一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。</p>

<h3 id="toc_7">计算字符数量</h3>

<p>如果想要获得一个字符串中的 <code>Character</code> 值得数量，可以使用字符串的 <code>characters</code> 属性的 <code>count</code> 属性。</p>

<p>注意在 Swift 中，使用可拓展的字符群集作为 <code>Character</code> 值来连接或改变字符串时，并不一定会更改字符串的字符数量。</p>

<h2 id="toc_8">访问和修改字符串</h2>

<h3 id="toc_9">字符串索引</h3>

<p>使用 <code>startIndex</code> 属性可以获取一个 <code>String</code> 的第一个 <code>Character</code> 的索引。使用 <code>endIndex</code> 属性可以获取最后一个 <code>Character</code> 的后一个位置的索引，所以 <code>endIndex</code> 属性不能作为一个字符串的有效下标。如果 <code>String</code> 是空串，两者是相等的。</p>

<p><code>String.Index.predecessor()</code> 获得前一个索引，<code>successor()</code> 获得后一个索引。</p>

<p><code>Characters</code> 属性的 <code>indices</code> 属性会创建一个包含全部索引的范围（<code>Range</code>），用来在一个字符串中访问单个字符。</p>

<h3 id="toc_10">插入和删除</h3>

<ul>
<li><code>insert(_:atIndex:)</code>：在一个字符串的制定索引插入一个字符</li>
<li><code>insertContentsOf(_:at:)</code>：在一个字符串的指定索引插入一个字符串</li>
<li>`removeAtIndex(_:)：在一个字符串的指定索引删除一个字符</li>
<li><code>removeRange(_:)</code>：在一个字符串的指定索引删除一个子字符串</li>
</ul>

<h2 id="toc_11">比较字符串</h2>

<h3 id="toc_12">字符串/字符相等</h3>

<p>使用 <code>==</code> 和 <code>!=</code> 来比较两个字符/字符串是否相等/不等。</p>

<h3 id="toc_13">前缀/后缀相等</h3>

<ul>
<li><code>hasPrefix(_:)</code></li>
<li><code>hasSuffix(_:)</code></li>
</ul>

<h2 id="toc_14">字符串的 Unicode 表示形式（Unicode Representations of Strings）</h2>

<p>当一个 Unicode 字符串被写进文本文件或其他存储时，字符串中的 Unicode 标量会用 Unicode 定义的几种编码格式（encoding forms）编码。每一个字符串中的小块编码都被称为 <code>code units</code>。这些包括 UTF-8,UTF-16,UTF-32 编码格式。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：属性]]></title>
    <link href="http://forrestchang.github.io/14631242333306.html"/>
    <updated>2016-05-13T15:23:53+08:00</updated>
    <id>http://forrestchang.github.io/14631242333306.html</id>
    <content type="html"><![CDATA[
<p>属性将值跟特定的类、结构或枚举关联。存储常量或变量作为实例的一部分，而计算属性（不是存储）一个值。</p>

<ul>
<li>计算属性：类、结构体、枚举</li>
<li>存储属性：类、结构体</li>
</ul>

<h2 id="toc_0">存储属性</h2>

<h3 id="toc_1">延迟存储属性</h3>

<p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 <code>lazy</code> 来标记一个延迟存储属性。</p>

<p>必须将延迟存储属性声明称变量，因为属性的初始值可能在实例构造完成之后才会得到。<strong>而常量属性在构造过程完成之前必须要有初始值，因此无法声明称延迟属性。</strong></p>

<p>延迟属性很有用，当属性的值依赖于在实例的构造过程结束后才会知道影响值得外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它。</p>

<h2 id="toc_2">计算属性</h2>

<p>计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</p>

<h3 id="toc_3">便捷 setter 声明</h3>

<p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 <code>newValue</code>。</p>

<h3 id="toc_4">只读计算属性</h3>

<p>只有 getter 没有 setter 的计算属性就是<strong>只读计算属性</strong>。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</p>

<h2 id="toc_5">属性观察器</h2>

<p>属性观察器监控和响应属性值的变化，每次属性被设置新的值都会调用属性观察器，即使新值和当前值相同的时候也不例外。</p>

<p>可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值得变化。</p>

<ul>
<li><code>willSet</code> 在新的值被设置之前调用</li>
<li><code>didSet</code> 在新的值被设置之后立即调用</li>
</ul>

<p><code>willSet</code> 观察器会将新的属性值作为常量参数传入，在 <code>willSet</code> 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 <code>newValue</code> 表示。</p>

<p><code>didSet</code> 观察器会将旧的属性值作为参数传入，可以为该参数名或者使用默认参数名 <code>oldValue</code>。如果在 <code>didSet</code> 方法中再次对该属性赋值，那么新值会覆盖旧的值。</p>

<p>父类的属性在子类的构造器中被赋值时，它在父类中的 <code>willSet</code> 和 <code>didSet</code> 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。</p>

<p>如果将属性通过 in-out 方式传入函数， <code>willSet</code> 和 <code>didSet</code> 也会被调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。</p>

<h2 id="toc_6">全局变量和局部变量</h2>

<p>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</p>

<p>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记 <code>lazy</code>   修饰符。</p>

<p>局部范围的常量或变量从不延迟计算。</p>

<h2 id="toc_7">类型属性</h2>

<p>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 <code>lazy</code> 修饰符。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：集合类型]]></title>
    <link href="http://forrestchang.github.io/14627836147810.html"/>
    <updated>2016-05-09T16:46:54+08:00</updated>
    <id>http://forrestchang.github.io/14627836147810.html</id>
    <content type="html"><![CDATA[
<p>Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型来存储数据合集。数组（Array）是有序数据的集；集合（Sets）是无序无重复数据的集；字典（Dictionaries）是无序的键值对的集。</p>

<p><img src="media/14627836147810/14627837494241.jpg" alt=""/></p>

<h2 id="toc_0">集合的可变性</h2>

<p>在我们不需要改变集合的时候创建不可变集合是很好的实践（使用 <code>let</code>），如此 Swift 编译器可以优化我们创建的集合。</p>

<h2 id="toc_1">数组</h2>

<h3 id="toc_2">创建一个带有默认值的数组</h3>

<p>Swift 中的 Array 类型提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（count）和适当类型的初始值（repeatedValue）传入数组构造函数：</p>

<pre><code class="language-swift">var threeDoubles = [Double](count: 3, repeatedValue: 0.0)
</code></pre>

<h3 id="toc_3">通过两个数组相加创建一个数组</h3>

<p>我们可以使用加法操作符来组合两种已经存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来。</p>

<h3 id="toc_4">访问和修改数组</h3>

<p><code>isEmpty</code> 检查数组是否为空。</p>

<p>使用加法赋值运算符（<code>+=</code>）可以直接在数组后面添加一个或多个拥有相同类型的数据项。</p>

<p>调用数组的 <code>insert(_:atIndex:)</code>方法来在某个具体的索引值之前添加数据项。</p>

<h3 id="toc_5">数组的遍历</h3>

<p>如果我们同事需要每个数据项的值和索引值，可以使用 <code>enumerate()</code> 方法来进行数组遍历。<code>enumerate()</code> 返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历。</p>

<h2 id="toc_6">集合（Sets）</h2>

<p>集合用来存储相同类型且没有确定顺序的值。</p>

<p>Swift 中的 <code>Set</code> 类型被桥接到 <code>Foundation</code> 中的 <code>NSset</code> 类。</p>

<h3 id="toc_7">集合类型的哈希值</h3>

<p>一个类型为了存储在集合中，该类型必须是可哈希化得——也就是说，该类型必须提供一个方法来计算它的哈希值。一个哈希值是 <code>Int</code> 类型的，相等的对象哈希值必须相同，比如<code>a=b</code>，因此必须是<code>a.hashValue = b.hashValue</code>。</p>

<p>Swift 的所有基本类型默认都是可哈希化的，可以作为集合的值类型或者字典的键类型。没有关联值的枚举成员值默认也是可哈希化的。</p>

<p>你可以使用你自定义的类型作为集合的值类型或者是字典的键的类型，但你需要使你的自定义类型符合 Swift 标准库中的 <code>Hashable</code> 协议。符合 <code>Hashable</code> 协议的类型需要提供一个类型为 <code>Int</code> 的可读属性 <code>hashValue</code>。由类型的 <code>hashValue</code> 属性返回的值不需要再同一程序的不同执行周期或者不同程序之间保持相同。</p>

<p>因为 <code>hashValue</code> 协议符合 <code>Equatable</code> 协议，所以符合该协的类型也必须停工一个 <code>==</code> 运算符的实现。这个 <code>Equatable</code> 协议要求任何符合 <code>==</code> 实现的实例间都是一种相等的关系，也就是说，对于 a, b, c 三个值来说，必须满足下面三种情况：</p>

<ul>
<li>自反性：a == a</li>
<li>对称性：a == b, b == a</li>
<li>传递性：a == b &amp;&amp; b == c, a == c</li>
</ul>

<h3 id="toc_8">遍历一个集合</h3>

<p>Swift 中的 <code>Set</code> 类型没有确定的顺序，为了按照特定顺序来遍历一个 <code>Set</code> 中的值可以使用 <code>sort()</code> 方法，它将根据提供的序列返回一个有序集合。</p>

<pre><code class="language-swift">for genre in favoriteGenres.sort() {...}
</code></pre>

<h3 id="toc_9">集合操作</h3>

<p><img src="media/14627836147810/14627853736261.jpg" alt=""/></p>

<p><img src="media/14627836147810/14627854301808.jpg" alt=""/></p>

<p><img src="media/14627836147810/14627854415802.jpg" alt=""/></p>

<h2 id="toc_10">字典</h2>

<p>字典中的数据项并没有具体顺序。</p>

<p>Swift 中 Dictionary 类型被桥接到 Foundation 中的 NSDictionary 类。</p>

<h3 id="toc_11">字典遍历</h3>

<ol>
<li>元组方式</li>
<li>dic.keys</li>
<li>dic.values</li>
</ol>

<p>如果我们只是需要某个字典的键值集合来作为某个接受 Array 实例的 API 的参数，可以直接使用 keys 或 values 属性构造一个新数组。</p>

<pre><code class="language-swift">let airportCodes = [String](airports.keys)
let airportNames = [String](airports.values)
</code></pre>

<p>Swift 的字典类型书无序集合类型。为了以特定的顺序便利字典的键或值，可以对字典的 keys 或 values 属性使用 <code>sort()</code> 方法。</p>

]]></content>
  </entry>
  
</feed>
